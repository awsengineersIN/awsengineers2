```python
"""
SSM Patch Compliance Dashboard

Features:
- Filter by account and region
- View patch compliance status across instances
- Patch compliance summary with aggregated statistics
- Detailed patch compliance report by instance
- Patch details with severity breakdown
- Tabs: Compliance Summary, Instances, Available Patches, Missing Patches
- Color-coded compliance status (RED for Non-Compliant, YELLOW for Compliant with Issues, GREEN for Compliant)
- Metrics: Compliant, Non-Compliant, Unspecified instances
- CSV export
- Graphs and charts for analysis

Uses your utils.py
"""

import streamlit as st
import pandas as pd
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor, as_completed
import time
import boto3
import plotly.graph_objects as go
import plotly.express as px

from utils import assume_role, setup_account_filter, get_account_name_by_id

# ============================================================================
# PAGE CONFIG & STATE
# ============================================================================

st.set_page_config(page_title="Patch Compliance", page_icon="üîß", layout="wide")

if 'pc_data' not in st.session_state:
    st.session_state.pc_data = None
if 'pc_refresh_time' not in st.session_state:
    st.session_state.pc_refresh_time = None
if 'pc_fetch_clicked' not in st.session_state:
    st.session_state.pc_fetch_clicked = False

st.title("üîß SSM Patch Compliance Dashboard")

# ============================================================================
# AWS CLIENTS
# ============================================================================

def get_ssm(account_id, role, region):
    """Get SSM client for account"""
    try:
        creds = assume_role(account_id, role)
        if not creds:
            return None
        return boto3.client('ssm', region_name=region, 
            aws_access_key_id=creds['AccessKeyId'],
            aws_secret_access_key=creds['SecretAccessKey'],
            aws_session_token=creds['SessionToken'])
    except:
        return None

def get_ec2(account_id, role, region):
    """Get EC2 client for account"""
    try:
        creds = assume_role(account_id, role)
        if not creds:
            return None
        return boto3.client('ec2', region_name=region,
            aws_access_key_id=creds['AccessKeyId'],
            aws_secret_access_key=creds['SecretAccessKey'],
            aws_session_token=creds['SessionToken'])
    except:
        return None

def get_account_id_by_name(account_name, accounts):
    for acc in accounts:
        if acc.get('name') == account_name:
            return acc.get('id')
    return None

# ============================================================================
# DATA COLLECTION
# ============================================================================

def fetch_account_region_data(account_id, account_name, region, role):
    """Fetch patch compliance for single account/region"""
    instances = []
    groups = []
    patches = []
    errors = []
    
    ssm = get_ssm(account_id, role, region)
    ec2 = get_ec2(account_id, role, region)
    
    if not ssm or not ec2:
        errors.append(f"‚ùå {account_name}/{region}: Auth failed")
        return instances, groups, patches, errors
    
    # Get all EC2 instances
    instance_map = {}
    try:
        paginator = ec2.get_paginator('describe_instances')
        for page in paginator.paginate(Filters=[{'Name': 'instance-state-name', 'Values': ['running', 'stopped']}]):
            for res in page.get('Reservations', []):
                for inst in res.get('Instances', []):
                    iid = inst['InstanceId']
                    instance_map[iid] = {
                        'name': next((t['Value'] for t in inst.get('Tags', []) if t['Key'] == 'Name'), iid),
                        'platform': inst.get('Platform', 'windows') or 'linux',
                        'state': inst['State']['Name'],
                        'launch': inst.get('LaunchTime', None),
                        'managed': False
                    }
    except Exception as e:
        errors.append(f"‚ö†Ô∏è {account_name}/{region}: EC2 error - {str(e)[:50]}")
    
    # Get managed instances
    managed_ids = set()
    try:
        paginator = ssm.get_paginator('describe_instance_information')
        for page in paginator.paginate():
            for inst in page.get('InstanceInformationList', []):
                iid = inst['InstanceId']
                managed_ids.add(iid)
                if iid in instance_map:
                    instance_map[iid]['managed'] = True
    except Exception as e:
        errors.append(f"‚ö†Ô∏è {account_name}/{region}: SSM instances - {str(e)[:50]}")
    
    # Get patch states
    try:
        if managed_ids:
            managed_list = list(managed_ids)
            batch_size = 50
            for i in range(0, len(managed_list), batch_size):
                batch = managed_list[i:i+batch_size]
                patch_states = ssm.describe_instance_patch_states(InstanceIds=batch)['InstancePatchStates']
                for state in patch_states:
                    iid = state['InstanceId']
                    if iid not in instance_map:
                        continue
                    
                    installed = state.get('InstalledCount', 0)
                    missing = state.get('MissingCount', 0)
                    failed = state.get('FailedCount', 0)
                    unspecified = state.get('NotApplicableCount', 0) + state.get('UnreportedNotApplicableCount', 0)
                    
                    if failed > 0:
                        status = 'NON_COMPLIANT'
                    elif missing > 0:
                        status = 'NON_COMPLIANT'
                    elif unspecified > 0:
                        status = 'UNSPECIFIED'
                    else:
                        status = 'COMPLIANT'
                    
                    instances.append({
                        'Account Name': account_name,
                        'Region': region,
                        'Instance ID': iid,
                        'Instance Name': instance_map[iid]['name'],
                        'Platform': instance_map[iid]['platform'],
                        'Compliance Status': status,
                        'Installed Patches': installed,
                        'Missing Patches': missing,
                        'Failed Patches': failed,
                        'Unspecified Patches': unspecified,
                        'Instance State': instance_map[iid]['state'],
                        'Launch Time': instance_map[iid]['launch'],
                        'Managed': True
                    })
                    instance_map[iid]['managed'] = True
    except Exception as e:
        errors.append(f"‚ö†Ô∏è {account_name}/{region}: Patch states - {str(e)[:50]}")
    
    # Add unmanaged instances
    for iid, info in instance_map.items():
        if not info['managed']:
            instances.append({
                'Account Name': account_name,
                'Region': region,
                'Instance ID': iid,
                'Instance Name': info['name'],
                'Platform': info['platform'],
                'Compliance Status': 'UNMANAGED',
                'Installed Patches': 0,
                'Missing Patches': 0,
                'Failed Patches': 0,
                'Unspecified Patches': 0,
                'Instance State': info['state'],
                'Launch Time': info['launch'],
                'Managed': False
            })
    
    # Get patch groups (Compliance Summary)
    try:
        paginator = ssm.get_paginator('describe_patch_groups')
        for page in paginator.paginate():
            for group in page.get('Mappings', []):
                group_name = group.get('PatchGroup', 'N/A')
                baseline_id = group.get('BaselineIdentity', {}).get('BaselineId', 'N/A')
                
                try:
                    resp = ssm.describe_patch_group_state(PatchGroup=group_name)
                    count = resp.get('Instances', 0)
                    if count > 0:  # Only append if there are instances to avoid empty rows
                        groups.append({
                            'Account Name': account_name,
                            'Region': region,
                            'Patch Group': group_name,
                            'Baseline ID': baseline_id,
                            'Instances Count': count,
                            'Compliant': resp.get('InstancesWithInstalledPatches', 0),
                            'Non-Compliant': resp.get('InstancesWithMissingPatches', 0) + resp.get('InstancesWithFailedPatches', 0),
                            'Unspecified': resp.get('InstancesWithNotApplicablePatches', 0) + resp.get('InstancesWithUnreportedNotApplicablePatches', 0)
                        })
                except:
                    pass
    except Exception as e:
        errors.append(f"‚ö†Ô∏è {account_name}/{region}: Patch groups - {str(e)[:50]}")
    
    # Get available patches
    try:
        paginator = ssm.get_paginator('describe_available_patches')
        for page in paginator.paginate():
            for patch in page.get('Patches', []):
                patches.append({
                    'Account Name': account_name,
                    'Region': region,
                    'Patch ID': patch.get('Id', 'N/A'),
                    'Title': patch.get('Title', 'N/A'),
                    'Classification': patch.get('Classification', 'N/A'),
                    'Severity': patch.get('Severity', 'N/A'),
                    'Release Date': patch.get('ReleaseDate', None),
                    'Content URL': patch.get('ContentUrl', 'N/A')
                })
    except Exception as e:
        errors.append(f"‚ö†Ô∏è {account_name}/{region}: Patches - {str(e)[:50]}")
    
    return instances, groups, patches, errors

def fetch_all_data(account_ids, accounts, regions):
    """Fetch from all accounts/regions in parallel"""
    all_inst = []
    all_grp = []
    all_pat = []
    all_err = []
    
    progress = st.progress(0)
    status = st.empty()
    total = len(account_ids) * len(regions)
    done = 0
    
    with ThreadPoolExecutor(max_workers=10) as exe:
        futures = {}
        for aid in account_ids:
            aname = get_account_name_by_id(aid, accounts)
            for rgn in regions:
                f = exe.submit(fetch_account_region_data, aid, aname, rgn, "readonly-role")
                futures[f] = (aname, rgn)
        
        for f in as_completed(futures):
            aname, rgn = futures[f]
            done += 1
            status.text(f"üì° {aname}/{rgn} ({done}/{total})")
            progress.progress(done / total)
            
            try:
                i, g, p, e = f.result()
                all_inst.extend(i)
                all_grp.extend(g)
                all_pat.extend(p)
                all_err.extend(e)
            except Exception as ex:
                all_err.append(f"‚ùå {aname}/{rgn}: {str(ex)[:50]}")
    
    progress.empty()
    status.empty()
    
    return all_inst, all_grp, all_pat, all_err

# ============================================================================
# SIDEBAR CONTROLS
# ============================================================================

account_ids, regions = setup_account_filter(page_key="patch")

st.sidebar.markdown("---")
debug_mode = st.sidebar.checkbox("Show Debug Info", value=False)

if st.sidebar.button("üìä Fetch Data", type="primary", use_container_width=True):
    st.session_state.pc_fetch_clicked = True

# ============================================================================
# FETCH DATA
# ============================================================================

if st.session_state.pc_fetch_clicked:
    if not account_ids or not regions:
        st.error("‚ùå Please select at least one account and region.")
        st.session_state.pc_fetch_clicked = False
    else:
        start = time.time()
        with st.spinner("üîç Scanning patch compliance..."):
            inst, grp, pat, err = fetch_all_data(account_ids, st.session_state.get('accounts', []), regions)
            st.session_state.pc_data = {'inst': inst, 'grp': grp, 'pat': pat, 'err': err}
            st.session_state.pc_refresh_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        elapsed = time.time() - start
        st.success(f"‚úÖ Patch compliance data fetched in {elapsed:.2f}s")
        if err:
            with st.expander(f"‚ö†Ô∏è Messages ({len(err)})", expanded=True):
                for e in err:
                    st.text(e)
        st.session_state.pc_fetch_clicked = False

# ============================================================================
# DISPLAY DASHBOARD
# ============================================================================

if debug_mode and st.session_state.pc_data and st.session_state.pc_data.get('err'):
    with st.expander("üêõ Debug Info"):
        for error in st.session_state.pc_data['err']:
            st.write(error)

if not st.session_state.pc_data:
    st.info("üëà Select accounts and regions, then click 'Fetch Data' button in sidebar")
else:
    data = st.session_state.pc_data
    inst_df = pd.DataFrame(data['inst']) if data['inst'] else pd.DataFrame()
    grp_df = pd.DataFrame(data['grp']) if data['grp'] else pd.DataFrame()
    pat_df = pd.DataFrame(data['pat']) if data['pat'] else pd.DataFrame()
    
    if not inst_df.empty:
        inst_df['Launch Time Display'] = inst_df['Launch Time'].apply(lambda x: x.strftime('%Y-%m-%d %H:%M:%S') if isinstance(x, datetime) else 'N/A')
    if not pat_df.empty:
        pat_df['Release Date Display'] = pat_df['Release Date'].apply(lambda x: x.strftime('%Y-%m-%d') if isinstance(x, datetime) else 'N/A')
    
    if inst_df.empty and grp_df.empty and pat_df.empty:
        st.warning("‚ö†Ô∏è No patch compliance data found.")
    else:
        # Last refresh time
        if st.session_state.pc_refresh_time:
            col1, col2 = st.columns([5, 1])
            with col1:
                st.caption(f"Last refreshed: {st.session_state.pc_refresh_time}")
            with col2:
                if st.button("üîÅ Refresh", type="secondary", use_container_width=True):
                    start = time.time()
                    with st.spinner("üîç Refreshing..."):
                        inst, grp, pat, err = fetch_all_data(account_ids, st.session_state.get('accounts', []), regions)
                        st.session_state.pc_data = {'inst': inst, 'grp': grp, 'pat': pat, 'err': err}
                        st.session_state.pc_refresh_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                    elapsed = time.time() - start
                    st.success(f"‚úÖ Refreshed in {elapsed:.2f}s")
                    if err:
                        with st.expander(f"‚ö†Ô∏è Messages ({len(err)})"):
                            for e in err:
                                st.text(e)
                    st.rerun()
        
        st.markdown("---")
        
        # ===== METRICS =====
        st.subheader("üìä Summary")
        
        comp = len(inst_df[inst_df['Compliance Status'] == 'COMPLIANT']) if not inst_df.empty else 0
        non_comp = len(inst_df[inst_df['Compliance Status'] == 'NON_COMPLIANT']) if not inst_df.empty else 0
        unsp = len(inst_df[inst_df['Compliance Status'] == 'UNSPECIFIED']) if not inst_df.empty else 0
        unmg = len(inst_df[inst_df['Compliance Status'] == 'UNMANAGED']) if not inst_df.empty else 0
        total = len(inst_df)
        mngd = total - unmg
        total_missing = int(inst_df['Missing Patches'].sum()) if not inst_df.empty else 0
        
        m1, m2, m3, m4, m5 = st.columns(5)
        with m1:
            st.metric("üü¢ Compliant", comp)
        with m2:
            st.metric("üî¥ Non-Compliant", non_comp)
        with m3:
            st.metric("üü° Unspecified", unsp)
        with m4:
            st.metric("Total Instances", total)
        with m5:
            if total > 0:
                pct = (comp / total) * 100
                st.metric("Compliance %", f"{pct:.1f}%")
        
        st.markdown("---")
        
        # ===== FILTERS =====
        st.subheader("üîç Filters")
        f1, f2, f3 = st.columns(3)
        
        with f1:
            acc_opts = sorted(inst_df['Account Name'].unique()) if not inst_df.empty else []
            acc_sel = st.multiselect("Account:", acc_opts, default=acc_opts, key="patch_account")
        
        with f2:
            rgn_opts = sorted(inst_df['Region'].unique()) if not inst_df.empty else []
            rgn_sel = st.multiselect("Region:", rgn_opts, default=rgn_opts, key="patch_region")
        
        with f3:
            sts_opts = sorted(inst_df['Compliance Status'].unique()) if not inst_df.empty else []
            sts_sel = st.multiselect("Compliance Status:", sts_opts, default=sts_opts, key="patch_status")
        
        filtered_inst = inst_df[(inst_df['Account Name'].isin(acc_sel)) & 
                                (inst_df['Region'].isin(rgn_sel)) & 
                                (inst_df['Compliance Status'].isin(sts_sel))] if not inst_df.empty else pd.DataFrame()
        
        filtered_pat = pat_df[(pat_df['Account Name'].isin(acc_sel)) & 
                              (pat_df['Region'].isin(rgn_sel))] if not pat_df.empty else pd.DataFrame()
        
        st.markdown("---")
        
        # ===== CHARTS =====
        st.subheader("üìà Overview")
        
        c1, c2, c3 = st.columns(3)
        
        # Managed vs Unmanaged
        with c1:
            mng_data = [mngd, unmg]
            mng_labs = ['Managed by SSM', 'Unmanaged']
            mng_cols = ['#28a745', '#dc3545']
            fig = go.Figure(data=[go.Pie(labels=mng_labs, values=mng_data, marker=dict(colors=mng_cols), hole=0.3)])
            fig.update_layout(title_text="Instance Management Status", height=400, showlegend=True)
            st.plotly_chart(fig, use_container_width=True)
        
        # Compliance
        with c2:
            comp_data = [comp, non_comp, unsp, unmg]
            comp_labs = ['Compliant', 'Non-Compliant', 'Unspecified', 'Unmanaged']
            comp_cols = ['#28a745', '#dc3545', '#ffc107', '#6c757d']
            comp_data_flt = [v for v, l in zip(comp_data, comp_labs) if v > 0]
            comp_labs_flt = [l for v, l in zip(comp_data, comp_labs) if v > 0]
            comp_cols_flt = [c for v, c in zip(comp_data, comp_cols) if v > 0]
            fig = go.Figure(data=[go.Pie(labels=comp_labs_flt, values=comp_data_flt, marker=dict(colors=comp_cols_flt), hole=0.3)])
            fig.update_layout(title_text="Compliance Summary", height=400, showlegend=True)
            st.plotly_chart(fig, use_container_width=True)
        
        # Non-compliance reasons
        with c3:
            if not filtered_inst.empty:
                miss_cnt = len(filtered_inst[filtered_inst['Missing Patches'] > 0])
                fail_cnt = len(filtered_inst[filtered_inst['Failed Patches'] > 0])
                if miss_cnt > 0 or fail_cnt > 0:
                    nc_data = []
                    nc_labs = []
                    nc_cols = []
                    if miss_cnt > 0:
                        nc_data.append(miss_cnt)
                        nc_labs.append('Missing Patches')
                        nc_cols.append('#fd7e14')
                    if fail_cnt > 0:
                        nc_data.append(fail_cnt)
                        nc_labs.append('Failed Patches')
                        nc_cols.append('#dc3545')
                    fig = go.Figure(data=[go.Pie(labels=nc_labs, values=nc_data, marker=dict(colors=nc_cols), hole=0.3)])
                    fig.update_layout(title_text="Non-Compliance Reasons", height=400, showlegend=True)
                    st.plotly_chart(fig, use_container_width=True)
                else:
                    st.info("‚ÑπÔ∏è No non-compliance data")
            else:
                st.info("‚ÑπÔ∏è No data to display")
        
        st.markdown("---")
        
        # Additional charts
        if not filtered_inst.empty:
            c1, c2 = st.columns(2)
            
            with c1:
                acc_counts = filtered_inst['Account Name'].value_counts()
                fig = go.Figure(data=[go.Bar(x=acc_counts.index, y=acc_counts.values, marker_color='#ff7f0e')])
                fig.update_layout(title_text="Instances by Account", xaxis_title="Account", yaxis_title="Count", height=400)
                st.plotly_chart(fig, use_container_width=True)
            
            with c2:
                plt_counts = filtered_inst['Platform'].value_counts()
                fig = go.Figure(data=[go.Bar(x=plt_counts.index, y=plt_counts.values, marker_color='#1f77b4')])
                fig.update_layout(title_text="Instances by Platform", xaxis_title="Platform", yaxis_title="Count", height=400)
                st.plotly_chart(fig, use_container_width=True)
            
            st.markdown("---")
        
        # ===== TABS =====
        tab1, tab2, tab3, tab4 = st.tabs(["üìã Compliance Summary", "üñ•Ô∏è Instances", "üîµ Available Patches", "üì¶ Missing Patches"])
        
        with tab1:
            st.subheader("Patch Compliance Summary by Patch Group")
            
            if not grp_df.empty:
                display_cols = ['Patch Group', 'Baseline ID', 'Instances Count', 'Compliant', 'Non-Compliant', 'Unspecified', 'Account Name', 'Region']
                display_df = grp_df[display_cols].reset_index(drop=True)
                
                st.dataframe(
                    display_df,
                    use_container_width=True,
                    height=500,
                    hide_index=True
                )
                
                csv = display_df.to_csv(index=False)
                st.download_button(
                    label="üì• Download Compliance Summary CSV",
                    data=csv,
                    file_name=f"compliance_summary_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                    mime="text/csv"
                )
            else:
                st.info("‚ÑπÔ∏è No compliance summary data available.")
        
        with tab2:
            st.subheader("Instance Patch Compliance Report")
            
            if not filtered_inst.empty:
                display_cols = ['Instance ID', 'Instance Name', 'Platform', 'Compliance Status', 'Managed', 'Installed Patches', 'Missing Patches', 'Failed Patches', 'Unspecified Patches', 'Instance State', 'Launch Time Display', 'Account Name', 'Region']
                display_df = filtered_inst[display_cols].sort_values('Compliance Status').reset_index(drop=True)
                
                def highlight_compliance(row):
                    status = row['Compliance Status']
                    if status == 'NON_COMPLIANT':
                        return ['background-color: #f8d7da'] * len(row)
                    elif status == 'UNSPECIFIED':
                        return ['background-color: #fff3cd'] * len(row)
                    elif status == 'UNMANAGED':
                        return ['background-color: #e2e3e5'] * len(row)
                    else:
                        return ['background-color: #d4edda'] * len(row)
                
                st.dataframe(
                    display_df.style.apply(highlight_compliance, axis=1),
                    use_container_width=True,
                    height=500,
                    hide_index=True
                )
                
                csv = display_df.to_csv(index=False)
                st.download_button(
                    label="üì• Download Instances CSV",
                    data=csv,
                    file_name=f"patch_instances_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                    mime="text/csv"
                )
            else:
                st.info("‚ÑπÔ∏è No instance data available.")
        
        with tab3:
            st.subheader("Available Patches")
            
            if not filtered_pat.empty:
                unique_patches = filtered_pat.drop_duplicates(subset=['Patch ID']).copy()
                
                display_cols = ['Patch ID', 'Title', 'Classification', 'Severity', 'Release Date Display', 'Content URL']
                display_df = unique_patches[display_cols].sort_values('Severity', ascending=False).reset_index(drop=True)
                
                def highlight_severity(row):
                    severity = row['Severity']
                    if severity == 'Critical':
                        return ['background-color: #dc3545'] * len(row)
                    elif severity == 'High':
                        return ['background-color: #fd7e14'] * len(row)
                    elif severity == 'Medium':
                        return ['background-color: #ffc107'] * len(row)
                    else:
                        return ['background-color: #d4edda'] * len(row)
                
                st.dataframe(
                    display_df.style.apply(highlight_severity, axis=1),
                    use_container_width=True,
                    height=500,
                    hide_index=True
                )
                
                csv = display_df.to_csv(index=False)
                st.download_button(
                    label="üì• Download Patches CSV",
                    data=csv,
                    file_name=f"available_patches_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                    mime="text/csv"
                )
            else:
                st.info("‚ÑπÔ∏è No patch data available.")
        
        with tab4:
            st.subheader("Missing Patches per Instance")
            
            if not filtered_inst.empty:
                selected_instance = st.selectbox("Select Instance:", options=filtered_inst['Instance ID'].unique())
                if selected_instance:
                    row = filtered_inst[filtered_inst['Instance ID'] == selected_instance].iloc[0]
                    account_name = row['Account Name']
                    region = row['Region']
                    
                    ssm = get_ssm(get_account_id_by_name(account_name, st.session_state.get('accounts', [])), "readonly-role", region)
                    if ssm:
                        try:
                            missing_patches = []
                            paginator = ssm.get_paginator('describe_instance_patches')
                            for page in paginator.paginate(InstanceId=selected_instance, Filters=[{'Key': 'State', 'Values': ['Missing']}]):
                                for patch in page.get('Patches', []):
                                    missing_patches.append({
                                        'Patch ID': patch.get('KBId', patch.get('Id', 'N/A')),
                                        'Title': patch.get('Title', 'N/A'),
                                        'Classification': patch.get('Classification', 'N/A'),
                                        'Severity': patch.get('Severity', 'N/A'),
                                        'Release Date': patch.get('ReleaseDate', 'N/A').strftime('%Y-%m-%d') if patch.get('ReleaseDate') else 'N/A'
                                    })
                            
                            if missing_patches:
                                missing_df = pd.DataFrame(missing_patches)
                                st.dataframe(missing_df, use_container_width=True)
                                
                                csv = missing_df.to_csv(index=False)
                                st.download_button(
                                    label="üì• Download Missing Patches CSV",
                                    data=csv,
                                    file_name=f"missing_patches_{selected_instance}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                                    mime="text/csv"
                                )
                            else:
                                st.info("No missing patches for this instance.")
                        except Exception as e:
                            st.error(f"Error fetching missing patches: {str(e)}")
                    else:
                        st.error("Failed to get SSM client for this account/region.")
            else:
                st.info("‚ÑπÔ∏è No instances available.")
```