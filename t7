import boto3
import json
import os
from datetime import datetime, timezone
from typing import Dict, List, Tuple, Any
import logging

# Configure logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)

class PatchComplianceReporter:
    def __init__(self):
        # Initialize AWS clients
        self.organizations_client = boto3.client('organizations')
        self.sts_client = boto3.client('sts')
        
        # Configuration
        self.regions = ['us-east-1', 'us-west-2']
        self.cross_account_role_name = os.environ.get('CROSS_ACCOUNT_ROLE_NAME', 'PatchComplianceRole')
        self.sender_email = os.environ.get('SENDER_EMAIL')
        self.recipient_emails = os.environ.get('RECIPIENT_EMAILS', '').split(',')
        
    def lambda_handler(self, event, context):
        """Main Lambda handler function"""
        try:
            logger.info("Starting patch compliance report generation")
            
            # Get all organization accounts
            accounts = self.get_organization_accounts()
            logger.info(f"Found {len(accounts)} accounts in organization")
            
            # Collect compliance data from all accounts and regions
            compliance_data = self.collect_compliance_data(accounts)
            
            # Generate and send email report
            self.generate_and_send_report(compliance_data)
            
            return {
                'statusCode': 200,
                'body': json.dumps('Patch compliance report generated successfully')
            }
            
        except Exception as e:
            logger.error(f"Error in lambda_handler: {str(e)}")
            raise
    
    def get_organization_accounts(self) -> List[Dict]:
        """Get all accounts in the AWS Organization"""
        accounts = []
        paginator = self.organizations_client.get_paginator('list_accounts')
        
        for page in paginator.paginate():
            for account in page['Accounts']:
                if account['Status'] == 'ACTIVE':
                    accounts.append({
                        'Id': account['Id'],
                        'Name': account['Name'],
                        'Email': account['Email']
                    })
        
        return accounts
    
    def assume_cross_account_role(self, account_id: str, region: str) -> boto3.Session:
        """Assume role in target account"""
        role_arn = f"arn:aws:iam::{account_id}:role/{self.cross_account_role_name}"
        
        try:
            response = self.sts_client.assume_role(
                RoleArn=role_arn,
                RoleSessionName=f"PatchCompliance-{account_id}-{region}"
            )
            
            credentials = response['Credentials']
            
            session = boto3.Session(
                aws_access_key_id=credentials['AccessKeyId'],
                aws_secret_access_key=credentials['SecretAccessKey'],
                aws_session_token=credentials['SessionToken'],
                region_name=region
            )
            
            return session
            
        except Exception as e:
            logger.error(f"Failed to assume role in account {account_id}: {str(e)}")
            return None
    
    def is_excluded_instance(self, instance: Dict) -> Tuple[bool, str]:
        """Check if an EC2 instance should be excluded from patch compliance reporting
        
        NOTE: This function should be conservative - only exclude instances that are 
        CLEARLY managed services. When in doubt, include the instance.
        """
        try:
            instance_id = instance.get('InstanceId', 'unknown')
            
            # Check tags for exclusion indicators
            tags = instance.get('Tags', [])
            tag_dict = {tag.get('Key', '').lower(): tag.get('Value', '').lower() for tag in tags}
            
            # Only exclude instances with EXPLICIT AWS managed service tags
            # Cloud9 detection - only with official AWS tags
            for tag_key, tag_value in tag_dict.items():
                if tag_key in ['aws:cloud9:environment', 'aws:cloud9:owner']:
                    return True, 'Cloud9'
            
            # WorkSpaces detection - only with official AWS tags
            for tag_key, tag_value in tag_dict.items():
                if tag_key in ['aws:workspaces:directory-id', 'aws:workspaces:bundle-id', 'aws:workspacesmanager:directory-id']:
                    return True, 'WorkSpaces'
            
            # EKS nodes detection - only with official Kubernetes tags
            for tag_key, tag_value in tag_dict.items():
                if tag_key.startswith('kubernetes.io/cluster/'):
                    return True, 'EKS'
                if tag_key.startswith('k8s.io/cluster-autoscaler/'):
                    return True, 'EKS'
                if tag_key in ['aws:eks:cluster-name', 'eks:cluster-name', 'eks:nodegroup-name']:
                    return True, 'EKS'
            
            # EMR nodes detection - only with official AWS tags
            for tag_key, tag_value in tag_dict.items():
                if tag_key in ['aws:elasticmapreduce:job-flow-id', 'aws:elasticmapreduce:instance-group-role']:
                    return True, 'EMR'
            
            # AWS Batch detection - only with official AWS tags
            for tag_key, tag_value in tag_dict.items():
                if tag_key in ['aws:batch:compute-environment', 'aws:batch:job-queue']:
                    return True, 'Batch'
            
            # Storage Gateway - only with official AWS tags
            for tag_key, tag_value in tag_dict.items():
                if tag_key in ['aws:storagegateway:gateway-id', 'aws:storagegateway:gateway-name']:
                    return True, 'Appliance'
            
            # Be more conservative with name-based detection - only very specific patterns
            instance_name = tag_dict.get('name', '')
            if instance_name:
                # Only exclude if name explicitly indicates AWS managed service
                if instance_name.startswith('aws-cloud9-'):
                    return True, 'Cloud9'
                if 'workspaces-' in instance_name and 'wsroot' in instance_name:
                    return True, 'WorkSpaces'
            
            return False, ''
            
        except Exception as e:
            logger.warning(f"Error checking if instance {instance.get('InstanceId', 'unknown')} should be excluded: {str(e)}")
            return False, ''
    
    def get_ec2_instances_in_region(self, session: boto3.Session) -> Tuple[List[str], int, int]:
        """Get EC2 instances in current region, return (all_instances, total_count, excluded_count)"""
        try:
            ec2_client = session.client('ec2')
            paginator = ec2_client.get_paginator('describe_instances')
            
            all_instances = []
            total_raw_count = 0
            exclusion_counts = {
                'Cloud9': 0, 'WorkSpaces': 0, 'EKS': 0, 'EMR': 0, 
                'Batch': 0, 'Appliance': 0
            }
            
            for page in paginator.paginate(
                Filters=[
                    {'Name': 'instance-state-name', 'Values': ['running', 'stopped']}
                ]
            ):
                for reservation in page['Reservations']:
                    for instance in reservation['Instances']:
                        total_raw_count += 1
                        instance_id = instance.get('InstanceId')
                        
                        is_excluded, exclusion_reason = self.is_excluded_instance(instance)
                        
                        if is_excluded:
                            exclusion_counts[exclusion_reason] += 1
                            logger.debug(f"Excluding {exclusion_reason} instance: {instance_id}")
                        else:
                            all_instances.append(instance_id)
            
            total_excluded = sum(exclusion_counts.values())
            if total_excluded > 0:
                exclusion_summary = ', '.join([f"{count} {service}" for service, count in exclusion_counts.items() if count > 0])
                logger.info(f"Region {session.region_name}: Excluded {total_excluded} managed service instances from {total_raw_count} total: {exclusion_summary}")
            
            logger.info(f"Region {session.region_name}: {len(all_instances)} patchable instances out of {total_raw_count} total EC2 instances")
            
            return all_instances, len(all_instances), total_excluded
            
        except Exception as e:
            logger.error(f"Error getting EC2 instances: {str(e)}")
            return [], 0, 0
    
    def get_ssm_managed_instances_in_region(self, session: boto3.Session) -> List[str]:
        """Get SSM managed instances in current region"""
        try:
            ssm_client = session.client('ssm')
            managed_instances = []
            
            paginator = ssm_client.get_paginator('describe_instance_information')
            for page in paginator.paginate():
                for instance in page['InstanceInformationList']:
                    if instance.get('PingStatus') == 'Online':
                        managed_instances.append(instance['InstanceId'])
            
            logger.info(f"Region {session.region_name}: Found {len(managed_instances)} SSM managed instances")
            return managed_instances
            
        except Exception as e:
            logger.error(f"Error getting SSM managed instances: {str(e)}")
            return []
    
    def get_instance_management_summary_corrected(self, session: boto3.Session) -> Dict:
        """Get EC2 instance management summary with corrected logic to prevent count mismatches"""
        try:
            # Get EC2 instances in this region (excluding managed services)
            patchable_instances, total_patchable_count, excluded_count = self.get_ec2_instances_in_region(session)
            
            # Get SSM managed instances in this region
            ssm_managed_instances = self.get_ssm_managed_instances_in_region(session)
            
            # Find intersection - SSM managed instances that are also patchable EC2 instances
            managed_patchable_instances = []
            for instance_id in ssm_managed_instances:
                if instance_id in patchable_instances:
                    managed_patchable_instances.append(instance_id)
            
            managed_count = len(managed_patchable_instances)
            not_managed_count = max(0, total_patchable_count - managed_count)
            
            # Validation check
            if managed_count > total_patchable_count:
                logger.error(f"Data inconsistency detected in {session.region_name}:")
                logger.error(f"  Managed instances: {managed_count}")
                logger.error(f"  Total patchable instances: {total_patchable_count}")
                logger.error(f"  SSM managed instances: {len(ssm_managed_instances)}")
                logger.error(f"  Raw EC2 instances (before exclusion): {total_patchable_count + excluded_count}")
                
                # Log SSM instances not found in EC2 (possible cross-region issue)
                missing_from_ec2 = [inst for inst in ssm_managed_instances if inst not in patchable_instances]
                if missing_from_ec2:
                    logger.error(f"  SSM instances not found in EC2 patchable list: {missing_from_ec2[:5]}...")
                
                # Use fallback calculation
                managed_count = min(managed_count, total_patchable_count)
                not_managed_count = max(0, total_patchable_count - managed_count)
            
            managed_percentage = round((managed_count / max(1, total_patchable_count)) * 100, 1) if total_patchable_count > 0 else 0.0
            
            logger.info(f"Region {session.region_name} summary:")
            logger.info(f"  Total patchable EC2 instances: {total_patchable_count}")
            logger.info(f"  SSM managed instances: {managed_count}")
            logger.info(f"  Not managed instances: {not_managed_count}")
            logger.info(f"  Managed percentage: {managed_percentage}%")
            
            return {
                'total_ec2_instances': total_patchable_count,
                'managed_instances': managed_count,
                'not_managed_instances': not_managed_count,
                'managed_percentage': managed_percentage
            }
            
        except Exception as e:
            logger.error(f"Error getting instance management summary: {str(e)}")
            return {
                'total_ec2_instances': 0,
                'managed_instances': 0,
                'not_managed_instances': 0,
                'managed_percentage': 0.0
            }
    
    def get_patch_compliance_summary_corrected(self, session: boto3.Session, managed_instances: int) -> Dict:
        """Get patch compliance summary with corrected totals"""
        try:
            ssm_client = session.client('ssm')
            
            response = ssm_client.list_compliance_summaries(
                Filters=[
                    {
                        'Key': 'ComplianceType',
                        'Values': ['Patch'],
                        'Type': 'EQUAL'
                    }
                ]
            )
            
            compliant_instances = 0
            non_compliant_instances = 0
            critical_count = 0
            
            for item in response.get('ComplianceSummaryItems', []):
                if item.get('ComplianceType') == 'Patch':
                    compliant_summary = item.get('CompliantSummary', {})
                    compliant_instances = compliant_summary.get('CompliantCount', 0)
                    
                    non_compliant_summary = item.get('NonCompliantSummary', {})
                    non_compliant_instances = non_compliant_summary.get('NonCompliantCount', 0)
                    
                    non_compliant_severity = non_compliant_summary.get('SeveritySummary', {})
                    critical_count = non_compliant_severity.get('CriticalCount', 0)
            
            reported_instances = compliant_instances + non_compliant_instances
            unreported_instances = max(0, managed_instances - reported_instances)
            
            # Additional validation
            if reported_instances > managed_instances:
                logger.warning(f"Region {session.region_name}: Compliance API reports more instances ({reported_instances}) than managed instances ({managed_instances})")
                logger.warning(f"  Adjusting compliance counts to match managed instance count")
                # Proportionally adjust the counts
                if reported_instances > 0:
                    adjustment_factor = managed_instances / reported_instances
                    compliant_instances = int(compliant_instances * adjustment_factor)
                    non_compliant_instances = int(non_compliant_instances * adjustment_factor)
                    critical_count = int(critical_count * adjustment_factor)
                unreported_instances = max(0, managed_instances - compliant_instances - non_compliant_instances)
            
            return {
                'compliant_instances': compliant_instances,
                'non_compliant_instances': non_compliant_instances,
                'unreported_instances': unreported_instances,
                'critical_count': critical_count
            }
            
        except Exception as e:
            logger.error(f"Error getting patch compliance summary: {str(e)}")
            return {
                'compliant_instances': 0,
                'non_compliant_instances': 0,
                'unreported_instances': managed_instances,
                'critical_count': 0
            }
    
    def get_detailed_patch_counts(self, session: boto3.Session) -> Dict:
        """Get detailed patch counts from patch states"""
        try:
            ssm_client = session.client('ssm')
            
            managed_instances = self.get_ssm_managed_instances_in_region(session)
            
            if not managed_instances:
                return self.get_empty_patch_counts()
            
            patch_details = {
                'missing_count': 0,
                'failed_count': 0,
                'installed_pending_reboot_count': 0
            }
            
            batch_size = 50
            for i in range(0, len(managed_instances), batch_size):
                batch = managed_instances[i:i+batch_size]
                
                try:
                    response = ssm_client.describe_instance_patch_states(
                        InstanceIds=batch
                    )
                    
                    for state in response.get('InstancePatchStates', []):
                        patch_details['missing_count'] += max(0, state.get('MissingCount', 0))
                        patch_details['failed_count'] += max(0, state.get('FailedCount', 0))
                        patch_details['installed_pending_reboot_count'] += max(0, state.get('InstalledPendingRebootCount', 0))
                    
                except Exception as batch_error:
                    logger.warning(f"Error processing patch states batch {i}-{i+batch_size}: {str(batch_error)}")
                    continue
            
            return patch_details
            
        except Exception as e:
            logger.error(f"Error getting detailed patch counts: {str(e)}")
            return self.get_empty_patch_counts()
    
    def get_empty_patch_counts(self) -> Dict:
        """Return empty patch counts structure"""
        return {
            'missing_count': 0,
            'failed_count': 0,
            'installed_pending_reboot_count': 0
        }
    
    def collect_compliance_data(self, accounts: List[Dict]) -> Dict:
        """Collect patch compliance data"""
        all_data = {
            'accounts': {},
            'generation_time': datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S UTC'),
            'organization_summary': {
                'total_ec2_instances': 0,
                'managed_instances': 0,
                'not_managed_instances': 0,
                'managed_percentage': 0.0,
                'compliant_instances': 0,
                'non_compliant_instances': 0,
                'unreported_instances': 0,
                'critical_count': 0,
                'missing_count': 0,
                'failed_count': 0,
                'installed_pending_reboot_count': 0
            }
        }
        
        for account in accounts:
            account_id = account['Id']
            account_name = account['Name']
            
            logger.info(f"Processing account: {account_name} ({account_id})")
            
            account_data = {
                'account_name': account_name,
                'account_id': account_id,
                'regions': {}
            }
            
            account_has_data = False
            
            for region in self.regions:
                logger.info(f"Processing region: {region}")
                
                session = self.assume_cross_account_role(account_id, region)
                if not session:
                    continue
                
                # Use corrected instance management summary
                instance_mgmt_summary = self.get_instance_management_summary_corrected(session)
                
                if instance_mgmt_summary['total_ec2_instances'] == 0:
                    logger.info(f"No patchable EC2 instances found in {account_name} - {region}")
                    continue
                
                account_has_data = True
                
                patch_compliance_summary = self.get_patch_compliance_summary_corrected(
                    session, 
                    instance_mgmt_summary['managed_instances']
                )
                
                detailed_patch_counts = self.get_detailed_patch_counts(session)
                
                # Final validation before storing data
                managed_instances = instance_mgmt_summary['managed_instances']
                total_instances = instance_mgmt_summary['total_ec2_instances']
                
                if managed_instances > total_instances:
                    logger.error(f"CRITICAL: Managed instances ({managed_instances}) > Total instances ({total_instances}) in {account_name}-{region}")
                    logger.error("This should not happen with the corrected logic. Adjusting managed count.")
                    managed_instances = total_instances
                    instance_mgmt_summary['managed_instances'] = managed_instances
                    instance_mgmt_summary['not_managed_instances'] = 0
                    instance_mgmt_summary['managed_percentage'] = 100.0 if total_instances > 0 else 0.0
                
                region_data = {
                    'total_ec2_instances': instance_mgmt_summary['total_ec2_instances'],
                    'managed_instances': instance_mgmt_summary['managed_instances'],
                    'not_managed_instances': instance_mgmt_summary['not_managed_instances'],
                    'managed_percentage': instance_mgmt_summary['managed_percentage'],
                    'compliant_instances': patch_compliance_summary['compliant_instances'],
                    'non_compliant_instances': patch_compliance_summary['non_compliant_instances'],
                    'unreported_instances': patch_compliance_summary['unreported_instances'],
                    'critical_count': patch_compliance_summary['critical_count'],
                    'missing_count': detailed_patch_counts['missing_count'],
                    'failed_count': detailed_patch_counts['failed_count'],
                    'installed_pending_reboot_count': detailed_patch_counts['installed_pending_reboot_count']
                }
                
                account_data['regions'][region] = region_data
                
                org_summary = all_data['organization_summary']
                org_summary['total_ec2_instances'] += instance_mgmt_summary['total_ec2_instances']
                org_summary['managed_instances'] += instance_mgmt_summary['managed_instances']
                org_summary['not_managed_instances'] += instance_mgmt_summary['not_managed_instances']
                org_summary['compliant_instances'] += patch_compliance_summary['compliant_instances']
                org_summary['non_compliant_instances'] += patch_compliance_summary['non_compliant_instances']
                org_summary['unreported_instances'] += patch_compliance_summary['unreported_instances']
                org_summary['critical_count'] += patch_compliance_summary['critical_count']
                org_summary['missing_count'] += detailed_patch_counts['missing_count']
                org_summary['failed_count'] += detailed_patch_counts['failed_count']
                org_summary['installed_pending_reboot_count'] += detailed_patch_counts['installed_pending_reboot_count']
            
            if account_has_data:
                all_data['accounts'][account_id] = account_data
        
        org_summary = all_data['organization_summary']
        total_instances = org_summary['total_ec2_instances']
        managed_instances = org_summary['managed_instances']
        
        if total_instances > 0:
            org_summary['managed_percentage'] = round((managed_instances / total_instances) * 100, 1)
        
        return all_data
    
    def generate_simple_email_report(self, compliance_data: Dict) -> str:
        """Generate simple, clean HTML email report with plain tabular data"""
        
        org_summary = compliance_data['organization_summary']
        
        managed_instances = org_summary['managed_instances']
        compliant_instances = org_summary['compliant_instances']
        non_compliant_instances = org_summary['non_compliant_instances']
        unreported_instances = org_summary['unreported_instances']
        
        compliant_pct = round((compliant_instances / max(1, managed_instances)) * 100, 1) if managed_instances > 0 else 0.0
        non_compliant_pct = round((non_compliant_instances / max(1, managed_instances)) * 100, 1) if managed_instances > 0 else 0.0
        unreported_pct = round((unreported_instances / max(1, managed_instances)) * 100, 1) if managed_instances > 0 else 0.0
        
        html = f"""<!DOCTYPE html>
<html>
<head>
    <style>
        body {{
            font-family: Arial, sans-serif;
            margin: 20px;
            font-size: 14px;
        }}
        table {{
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }}
        th, td {{
            border: 1px solid black;
            padding: 8px;
            text-align: left;
        }}
        th {{
            background-color: #f0f0f0;
        }}
        h1, h2 {{
            font-weight: normal;
        }}
    </style>
</head>
<body>
    <h1>AWS Patch Compliance Report</h1>
    <p>Generated: {compliance_data['generation_time']}</p>
    <p>Organization: Multi-Account AWS Organization</p>
    <p>Regions: {', '.join(self.regions)}</p>
    <p>Note: Excluded managed service instances with conservative filtering to ensure data accuracy.</p>
    
    <h2>EC2 Instance Management Summary</h2>
    <table>
        <tr>
            <th>Status</th>
            <th>Count</th>
            <th>Percentage</th>
        </tr>
        <tr>
            <td>Total EC2 Instances</td>
            <td>{org_summary['total_ec2_instances']:,}</td>
            <td>100.0%</td>
        </tr>
        <tr>
            <td>Managed by Systems Manager</td>
            <td>{org_summary['managed_instances']:,}</td>
            <td>{org_summary['managed_percentage']}%</td>
        </tr>
        <tr>
            <td>Not Managed by Systems Manager</td>
            <td>{org_summary['not_managed_instances']:,}</td>
            <td>{round(100 - org_summary['managed_percentage'], 1)}%</td>
        </tr>
    </table>
    
    <h2>Patch Compliance Summary</h2>
    <table>
        <tr>
            <th>Compliance Status</th>
            <th>Count</th>
            <th>Percentage</th>
        </tr>
        <tr>
            <td>Total Managed Instances</td>
            <td>{managed_instances:,}</td>
            <td>100.0%</td>
        </tr>
        <tr>
            <td>Compliant</td>
            <td>{compliant_instances:,}</td>
            <td>{compliant_pct}%</td>
        </tr>
        <tr>
            <td>Non-Compliant</td>
            <td>{non_compliant_instances:,}</td>
            <td>{non_compliant_pct}%</td>
        </tr>"""
        
        if unreported_instances > 0:
            html += f"""
        <tr>
            <td>No Compliance Data</td>
            <td>{unreported_instances:,}</td>
            <td>{unreported_pct}%</td>
        </tr>"""
        
        html += """
    </table>
    """
        
        if compliance_data['accounts']:
            html += """
    <h2>Account and Region Details</h2>
    <table>
        <tr>
            <th>Account Name</th>
            <th>Account ID</th>
            <th>Region</th>
            <th>Total EC2</th>
            <th>Managed</th>
            <th>SSM %</th>
            <th>Compliant</th>
            <th>Non-Compliant</th>
            <th>Critical</th>
            <th>Missing</th>
            <th>Failed</th>
            <th>Pending Reboot</th>
        </tr>"""
            
            for account_id, account_data in compliance_data['accounts'].items():
                account_name = account_data['account_name']
                
                for region, region_data in account_data['regions'].items():
                    html += f"""
        <tr>
            <td>{account_name}</td>
            <td>{account_id}</td>
            <td>{region}</td>
            <td>{region_data['total_ec2_instances']}</td>
            <td>{region_data['managed_instances']}</td>
            <td>{region_data['managed_percentage']}%</td>
            <td>{region_data['compliant_instances']}</td>
            <td>{region_data['non_compliant_instances']}</td>
            <td>{region_data['critical_count']}</td>
            <td>{region_data['missing_count']}</td>
            <td>{region_data['failed_count']}</td>
            <td>{region_data['installed_pending_reboot_count']}</td>
        </tr>"""
            
            html += """
    </table>"""
        
        html += f"""
    
    <p>Report generated by AWS Patch Compliance Reporter</p>
    <p>Verification: Compliant ({compliant_instances:,}) + Non-Compliant ({non_compliant_instances:,}) + No Data ({unreported_instances:,}) = Total Managed ({managed_instances:,})</p>
</body>
</html>"""
        
        return html
    
    def generate_and_send_report(self, compliance_data: Dict):
        """Generate and send simple email report"""
        try:
            html_body = self.generate_simple_email_report(compliance_data)
            
            org_summary = compliance_data['organization_summary']
            managed_instances = org_summary['managed_instances']
            compliant_instances = org_summary['compliant_instances']
            compliant_pct = round((compliant_instances / max(1, managed_instances)) * 100, 1) if managed_instances > 0 else 0.0
            
            subject = f"AWS Patch Compliance Report - {org_summary['total_ec2_instances']:,} total, {managed_instances:,} managed, {compliant_instances:,} compliant ({compliant_pct}%)"
            
            # Send email using your SES module
            # Uncomment and modify based on your SES setup:
            # send_email(
            #     sender_address=self.sender_email,
            #     receiver_addresses=self.recipient_emails,
            #     subject=subject,
            #     body=html_body
            # )
            
            logger.info(f"Email report generated successfully")
            logger.info(f"Subject: {subject}")
            
        except Exception as e:
            logger.error(f"Error generating email report: {str(e)}")
            raise

# Lambda handler entry point
def lambda_handler(event, context):
    reporter = PatchComplianceReporter()
    return reporter.lambda_handler(event, context)
