pipeline {
    agent any
    
    environment {
        // UPDATE THESE VALUES
        LAMBDA_ARN = 'arn:aws:lambda:us-east-1:123456789012:function:aws-inventory'
        LAMBDA_ROLE_ARN = 'arn:aws:iam::123456789012:role/JenkinsLambdaExecutionRole'
        EXTERNAL_ID = 'your-external-id-here'  // Remove if not needed
        AWS_DEFAULT_REGION = 'us-east-1'
    }
    
    stages {
        stage('Assume AWS Role') {
            steps {
                script {
                    echo "üîë Assuming AWS role for Lambda execution..."
                    
                    // Assume role command
                    def assumeRoleCmd = """
                        aws sts assume-role \\
                            --role-arn ${env.LAMBDA_ROLE_ARN} \\
                            --role-session-name jenkins-lambda-execution \\
                            --duration-seconds 3600
                    """
                    
                    // Add external ID if configured
                    if (env.EXTERNAL_ID && env.EXTERNAL_ID != 'your-external-id-here') {
                        assumeRoleCmd += " --external-id ${env.EXTERNAL_ID}"
                    }
                    
                    def result = sh(script: assumeRoleCmd, returnStdout: true).trim()
                    def roleResponse = new groovy.json.JsonSlurper().parseText(result)
                    
                    // Set temporary credentials
                    env.AWS_ACCESS_KEY_ID = roleResponse.Credentials.AccessKeyId
                    env.AWS_SECRET_ACCESS_KEY = roleResponse.Credentials.SecretAccessKey
                    env.AWS_SESSION_TOKEN = roleResponse.Credentials.SessionToken
                    
                    echo "‚úÖ Successfully assumed role"
                }
            }
        }
        
        stage('Execute Lambda') {
            steps {
                script {
                    echo "üöÄ Executing AWS Lambda function..."
                    
                    // Build payload
                    def resourceList = params.RESOURCES.tokenize(',').collect { it.trim() }
                    def payload = [
                        scope: params.SCOPE,
                        target: params.TARGET,
                        resources: resourceList,
                        email: params.EMAIL
                    ]
                    
                    if (params.FALLBACK_REGIONS && params.FALLBACK_REGIONS.trim() != '') {
                        payload.fallback_regions = params.FALLBACK_REGIONS.split(',').collect { it.trim() }
                    }
                    
                    def payloadJson = groovy.json.JsonOutput.toJson(payload)
                    
                    // Invoke Lambda
                    def lambdaCommand = """
                        aws lambda invoke \\
                            --function-name ${env.LAMBDA_ARN} \\
                            --payload '${payloadJson}' \\
                            --cli-binary-format raw-in-base64-out \\
                            --log-type Tail \\
                            lambda-response.json
                    """
                    
                    sh lambdaCommand
                    echo "‚úÖ Lambda function executed"
                }
            }
        }
        
        stage('Display Lambda Output') {
            steps {
                script {
                    echo "üìã Lambda Function Output:"
                    echo "=" * 80
                    
                    // Read and display response
                    def responseText = readFile('lambda-response.json').trim()
                    def response = new groovy.json.JsonSlurper().parseText(responseText)
                    
                    if (response.errorMessage) {
                        echo "‚ùå LAMBDA ERROR:"
                        echo "   ${response.errorMessage}"
                        if (response.stackTrace) {
                            echo "   Stack Trace:"
                            response.stackTrace.each { trace -> echo "     ${trace}" }
                        }
                        error("Lambda execution failed")
                    } else {
                        echo "‚úÖ LAMBDA SUCCESS:"
                        echo responseText
                    }
                    
                    echo "=" * 80
                }
            }
        }
        
        stage('Display Lambda Logs') {
            steps {
                script {
                    echo "üìú Lambda Execution Logs:"
                    echo "=" * 80
                    
                    try {
                        // Get function name from ARN
                        def functionName = env.LAMBDA_ARN.split(':')[6]
                        def logGroupName = "/aws/lambda/${functionName}"
                        
                        // Get latest log stream
                        def logStreamCmd = """
                            aws logs describe-log-streams \\
                                --log-group-name ${logGroupName} \\
                                --order-by LastEventTime \\
                                --descending \\
                                --max-items 1 \\
                                --query 'logStreams[0].logStreamName' \\
                                --output text
                        """
                        
                        def latestStream = sh(script: logStreamCmd, returnStdout: true).trim()
                        
                        if (latestStream && latestStream != 'None') {
                            // Get log events from last 10 minutes
                            def logEventsCmd = """
                                aws logs get-log-events \\
                                    --log-group-name ${logGroupName} \\
                                    --log-stream-name ${latestStream} \\
                                    --start-time \$(date -d '10 minutes ago' +%s)000 \\
                                    --query 'events[*].message' \\
                                    --output text
                            """
                            
                            def logs = sh(script: logEventsCmd, returnStdout: true).trim()
                            
                            if (logs && logs != '') {
                                echo logs
                            } else {
                                echo "No recent logs found"
                            }
                        } else {
                            echo "No log streams found"
                        }
                        
                    } catch (Exception e) {
                        echo "Could not retrieve logs: ${e.message}"
                    }
                    
                    echo "=" * 80
                }
            }
        }
    }
    
    post {
        always {
            script {
                // Cleanup
                sh 'rm -f lambda-response.json || true'
                env.AWS_ACCESS_KEY_ID = ''
                env.AWS_SECRET_ACCESS_KEY = ''
                env.AWS_SESSION_TOKEN = ''
                
                echo "üèÅ Pipeline completed"
            }
        }
        
        success {
            echo "üéâ AWS Inventory pipeline completed successfully!"
        }
        
        failure {
            echo "üí• AWS Inventory pipeline failed - check logs above"
        }
    }
}
