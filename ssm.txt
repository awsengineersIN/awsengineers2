Required SSM Documents
âœ… Existing AWS Documents (No creation needed):
AWS-RunPatchBaseline - Used for the actual patch retry operation

ðŸ†• New Custom Documents (Must be created):
CrossPlatformDiskCleanup

CrossPlatformServiceManagement

CrossPlatformServiceRestart

CrossPlatformNetworkTroubleshooting

CrossPlatformSSMAgentRecovery

Complete SSM Document Definitions
1. CrossPlatformDiskCleanup
json
{
  "schemaVersion": "2.2",
  "description": "Cross-platform disk cleanup for patch remediation",
  "parameters": {
    "executionTimeout": {
      "type": "String",
      "default": "3600",
      "description": "Timeout for command execution"
    }
  },
  "mainSteps": [
    {
      "action": "aws:runPowerShellScript",
      "name": "WindowsDiskCleanup",
      "precondition": {
        "StringEquals": ["platformType", "Windows"]
      },
      "inputs": {
        "timeoutSeconds": "{{ executionTimeout }}",
        "runCommand": [
          "Write-Output 'Starting Windows disk cleanup for patch remediation'",
          "# Clean temporary files older than 7 days",
          "Get-ChildItem -Path $env:TEMP -Recurse -ErrorAction SilentlyContinue | Where-Object {$_.LastWriteTime -lt (Get-Date).AddDays(-7)} | Remove-Item -Force -Recurse -ErrorAction SilentlyContinue",
          "Get-ChildItem -Path \"$env:WINDIR\\Temp\" -Recurse -ErrorAction SilentlyContinue | Where-Object {$_.LastWriteTime -lt (Get-Date).AddDays(-7)} | Remove-Item -Force -Recurse -ErrorAction SilentlyContinue",
          "# Run disk cleanup utility",
          "Start-Process -FilePath 'cleanmgr' -ArgumentList '/sagerun:1' -Wait -WindowStyle Hidden -ErrorAction SilentlyContinue",
          "# Check available disk space after cleanup",
          "$disk = Get-WmiObject -Class Win32_LogicalDisk -Filter \"DeviceID='C:'\"",
          "$freeSpaceGB = [math]::Round($disk.FreeSpace / 1GB, 2)",
          "Write-Output \"Available disk space after cleanup: $freeSpaceGB GB\"",
          "# Clean Windows Update cache",
          "Stop-Service wuauserv -Force -ErrorAction SilentlyContinue",
          "Remove-Item -Path 'C:\\Windows\\SoftwareDistribution\\Download\\*' -Recurse -Force -ErrorAction SilentlyContinue",
          "Start-Service wuauserv -ErrorAction SilentlyContinue",
          "Write-Output 'Windows disk cleanup completed successfully'"
        ]
      }
    },
    {
      "action": "aws:runShellScript",
      "name": "LinuxDiskCleanup",
      "precondition": {
        "StringEquals": ["platformType", "Linux"]
      },
      "inputs": {
        "timeoutSeconds": "{{ executionTimeout }}",
        "runCommand": [
          "#!/bin/bash",
          "echo 'Starting Linux disk cleanup for patch remediation'",
          "# Clean temporary files older than 7 days",
          "find /tmp -type f -atime +7 -delete 2>/dev/null || true",
          "find /var/tmp -type f -atime +7 -delete 2>/dev/null || true",
          "# Clean package manager cache",
          "if command -v yum &> /dev/null; then",
          "    yum clean all 2>/dev/null || true",
          "    echo 'YUM cache cleaned'",
          "elif command -v apt-get &> /dev/null; then",
          "    apt-get clean 2>/dev/null || true",
          "    apt-get autoclean 2>/dev/null || true",
          "    echo 'APT cache cleaned'",
          "elif command -v zypper &> /dev/null; then",
          "    zypper clean 2>/dev/null || true",
          "    echo 'Zypper cache cleaned'",
          "fi",
          "# Clean journal logs older than 30 days",
          "journalctl --vacuum-time=30d 2>/dev/null || true",
          "# Remove old log files",
          "find /var/log -name '*.log.*' -mtime +30 -delete 2>/dev/null || true",
          "find /var/log -name '*.gz' -mtime +30 -delete 2>/dev/null || true",
          "# Clean core dumps",
          "find /var/crash -name 'core.*' -mtime +7 -delete 2>/dev/null || true",
          "# Show disk usage after cleanup",
          "df -h / | grep -v Filesystem",
          "echo 'Linux disk cleanup completed successfully'"
        ]
      }
    }
  ]
}
2. CrossPlatformServiceManagement
json
{
  "schemaVersion": "2.2",
  "description": "Cross-platform service management for patch remediation",
  "parameters": {
    "executionTimeout": {
      "type": "String",
      "default": "3600",
      "description": "Timeout for command execution"
    }
  },
  "mainSteps": [
    {
      "action": "aws:runPowerShellScript",
      "name": "WindowsServiceManagement",
      "precondition": {
        "StringEquals": ["platformType", "Windows"]
      },
      "inputs": {
        "timeoutSeconds": "{{ executionTimeout }}",
        "runCommand": [
          "Write-Output 'Starting Windows service management for patch remediation'",
          "# Create directory for service tracking",
          "New-Item -ItemType Directory -Path 'C:\\temp' -Force -ErrorAction SilentlyContinue",
          "# Define services that commonly interfere with patching",
          "$conflictingServices = @('IISADMIN', 'W3SVC', 'MSSQLSERVER', 'SQLSERVERAGENT', 'MSSQLServerADHelper100', 'SQLBrowser', 'Spooler')",
          "$stoppedServices = @()",
          "# Stop conflicting services and track them",
          "foreach ($serviceName in $conflictingServices) {",
          "    $service = Get-Service -Name $serviceName -ErrorAction SilentlyContinue",
          "    if ($service -and $service.Status -eq 'Running') {",
          "        try {",
          "            Stop-Service -Name $service.Name -Force -ErrorAction Stop",
          "            $stoppedServices += $service.Name",
          "            Write-Output \"Successfully stopped service: $($service.Name)\"",
          "        } catch {",
          "            Write-Output \"Failed to stop service: $($service.Name) - $($_.Exception.Message)\"",
          "        }",
          "    } else {",
          "        Write-Output \"Service $serviceName not found or not running\"",
          "    }",
          "}",
          "# Save list of stopped services for restart later",
          "if ($stoppedServices.Count -gt 0) {",
          "    $stoppedServices | Out-File -FilePath 'C:\\temp\\stopped_services.txt' -Encoding UTF8",
          "    Write-Output \"Saved list of $($stoppedServices.Count) stopped services to C:\\temp\\stopped_services.txt\"",
          "} else {",
          "    Write-Output 'No services needed to be stopped'",
          "}",
          "Write-Output 'Windows service management completed successfully'"
        ]
      }
    },
    {
      "action": "aws:runShellScript",
      "name": "LinuxServiceManagement",
      "precondition": {
        "StringEquals": ["platformType", "Linux"]
      },
      "inputs": {
        "timeoutSeconds": "{{ executionTimeout }}",
        "runCommand": [
          "#!/bin/bash",
          "echo 'Starting Linux service management for patch remediation'",
          "# Define services that commonly interfere with patching",
          "SERVICES_TO_MANAGE=('httpd' 'nginx' 'apache2' 'mysql' 'mysqld' 'postgresql' 'tomcat' 'tomcat8' 'tomcat9' 'docker')",
          "STOPPED_SERVICES=()",
          "# Stop conflicting services and track them",
          "for service in \"${SERVICES_TO_MANAGE[@]}\"; do",
          "    if systemctl is-active --quiet \"$service\" 2>/dev/null; then",
          "        if systemctl stop \"$service\" 2>/dev/null; then",
          "            STOPPED_SERVICES+=(\"$service\")",
          "            echo \"Successfully stopped service: $service\"",
          "        else",
          "            echo \"Failed to stop service: $service\"",
          "        fi",
          "    else",
          "        echo \"Service $service not found or not running\"",
          "    fi",
          "done",
          "# Save list of stopped services for restart later",
          "if [ ${#STOPPED_SERVICES[@]} -gt 0 ]; then",
          "    printf '%s\\n' \"${STOPPED_SERVICES[@]}\" > /tmp/stopped_services.txt",
          "    echo \"Saved list of ${#STOPPED_SERVICES[@]} stopped services to /tmp/stopped_services.txt\"",
          "else",
          "    echo 'No services needed to be stopped'",
          "fi",
          "# Show current service states",
          "echo 'Current service states after management:'",
          "for service in \"${SERVICES_TO_MANAGE[@]}\"; do",
          "    if systemctl is-active --quiet \"$service\" 2>/dev/null; then",
          "        echo \"$service: RUNNING\"",
          "    else",
          "        echo \"$service: STOPPED\"",
          "    fi",
          "done",
          "echo 'Linux service management completed successfully'"
        ]
      }
    }
  ]
}
3. CrossPlatformServiceRestart
json
{
  "schemaVersion": "2.2",
  "description": "Cross-platform service restart after patch remediation",
  "parameters": {
    "executionTimeout": {
      "type": "String",
      "default": "1800",
      "description": "Timeout for command execution"
    }
  },
  "mainSteps": [
    {
      "action": "aws:runPowerShellScript",
      "name": "WindowsServiceRestart",
      "precondition": {
        "StringEquals": ["platformType", "Windows"]
      },
      "inputs": {
        "timeoutSeconds": "{{ executionTimeout }}",
        "runCommand": [
          "Write-Output 'Starting Windows service restart after patch remediation'",
          "$servicesFile = 'C:\\temp\\stopped_services.txt'",
          "if (Test-Path $servicesFile) {",
          "    $servicesToRestart = Get-Content $servicesFile -ErrorAction SilentlyContinue | Where-Object { $_.Trim() -ne '' }",
          "    $successCount = 0",
          "    $failCount = 0",
          "    foreach ($serviceName in $servicesToRestart) {",
          "        $serviceName = $serviceName.Trim()",
          "        if ($serviceName -ne '') {",
          "            try {",
          "                Start-Service -Name $serviceName -ErrorAction Stop",
          "                Write-Output \"Successfully restarted service: $serviceName\"",
          "                $successCount++",
          "                # Wait a moment between service starts",
          "                Start-Sleep -Seconds 5",
          "            } catch {",
          "                Write-Output \"Failed to restart service: $serviceName - $($_.Exception.Message)\"",
          "                $failCount++",
          "            }",
          "        }",
          "    }",
          "    Write-Output \"Service restart summary: $successCount successful, $failCount failed\"",
          "    # Clean up the tracking file",
          "    Remove-Item $servicesFile -Force -ErrorAction SilentlyContinue",
          "    Write-Output 'Cleaned up service tracking file'",
          "} else {",
          "    Write-Output 'No stopped services file found - no services to restart'",
          "}",
          "# Show final service status",
          "Write-Output 'Final service status check:'",
          "$criticalServices = @('IISADMIN', 'W3SVC', 'MSSQLSERVER')",
          "foreach ($service in $criticalServices) {",
          "    $svc = Get-Service -Name $service -ErrorAction SilentlyContinue",
          "    if ($svc) {",
          "        Write-Output \"$($svc.Name): $($svc.Status)\"",
          "    }",
          "}",
          "Write-Output 'Windows service restart completed'"
        ]
      }
    },
    {
      "action": "aws:runShellScript",
      "name": "LinuxServiceRestart",
      "precondition": {
        "StringEquals": ["platformType", "Linux"]
      },
      "inputs": {
        "timeoutSeconds": "{{ executionTimeout }}",
        "runCommand": [
          "#!/bin/bash",
          "echo 'Starting Linux service restart after patch remediation'",
          "SERVICES_FILE='/tmp/stopped_services.txt'",
          "if [ -f \"$SERVICES_FILE\" ]; then",
          "    SUCCESS_COUNT=0",
          "    FAIL_COUNT=0",
          "    while IFS= read -r service; do",
          "        if [ -n \"$service\" ] && [ \"$service\" != \"\" ]; then",
          "            if systemctl start \"$service\" 2>/dev/null; then",
          "                echo \"Successfully restarted service: $service\"",
          "                ((SUCCESS_COUNT++))",
          "                # Wait a moment between service starts",
          "                sleep 5",
          "            else",
          "                echo \"Failed to restart service: $service\"",
          "                ((FAIL_COUNT++))",
          "            fi",
          "        fi",
          "    done < \"$SERVICES_FILE\"",
          "    echo \"Service restart summary: $SUCCESS_COUNT successful, $FAIL_COUNT failed\"",
          "    # Clean up the tracking file",
          "    rm -f \"$SERVICES_FILE\"",
          "    echo 'Cleaned up service tracking file'",
          "else",
          "    echo 'No stopped services file found - no services to restart'",
          "fi",
          "# Show final service status",
          "echo 'Final service status check:'",
          "CRITICAL_SERVICES=('httpd' 'nginx' 'apache2' 'mysql' 'mysqld' 'postgresql')",
          "for service in \"${CRITICAL_SERVICES[@]}\"; do",
          "    if systemctl is-active --quiet \"$service\" 2>/dev/null; then",
          "        echo \"$service: RUNNING\"",
          "    elif systemctl list-unit-files --type=service | grep -q \"^$service.service\"; then",
          "        echo \"$service: STOPPED\"",
          "    fi",
          "done",
          "echo 'Linux service restart completed'"
        ]
      }
    }
  ]
}
4. CrossPlatformNetworkTroubleshooting
json
{
  "schemaVersion": "2.2",
  "description": "Cross-platform network troubleshooting for patch remediation",
  "parameters": {
    "executionTimeout": {
      "type": "String",
      "default": "1800",
      "description": "Timeout for command execution"
    }
  },
  "mainSteps": [
    {
      "action": "aws:runPowerShellScript",
      "name": "WindowsNetworkTroubleshooting",
      "precondition": {
        "StringEquals": ["platformType", "Windows"]
      },
      "inputs": {
        "timeoutSeconds": "{{ executionTimeout }}",
        "runCommand": [
          "Write-Output 'Starting Windows network troubleshooting for patch remediation'",
          "# Test basic connectivity",
          "Write-Output 'Testing basic connectivity...'",
          "try {",
          "    $result = Test-NetConnection -ComputerName '8.8.8.8' -Port 53 -WarningAction SilentlyContinue -ErrorAction Stop",
          "    Write-Output \"Basic connectivity to 8.8.8.8:53 - $($result.TcpTestSucceeded)\"",
          "} catch {",
          "    Write-Output 'Basic connectivity test failed'",
          "}",
          "# Test DNS resolution",
          "Write-Output 'Testing DNS resolution...'",
          "try {",
          "    $dnsResult = Resolve-DnsName 'google.com' -ErrorAction Stop",
          "    Write-Output 'DNS resolution: OK'",
          "} catch {",
          "    Write-Output 'DNS resolution: FAILED'",
          "    # Attempt DNS cache flush",
          "    Write-Output 'Attempting DNS cache flush...'",
          "    ipconfig /flushdns",
          "    Start-Sleep -Seconds 5",
          "    try {",
          "        Resolve-DnsName 'google.com' -ErrorAction Stop",
          "        Write-Output 'DNS resolution after flush: OK'",
          "    } catch {",
          "        Write-Output 'DNS resolution still failing after flush'",
          "    }",
          "}",
          "# Test Windows Update connectivity",
          "Write-Output 'Testing Windows Update connectivity...'",
          "$wuEndpoints = @('windowsupdate.microsoft.com', 'download.microsoft.com', 'update.microsoft.com')",
          "foreach ($endpoint in $wuEndpoints) {",
          "    try {",
          "        $result = Test-NetConnection -ComputerName $endpoint -Port 80 -WarningAction SilentlyContinue",
          "        Write-Output \"$endpoint : $($result.TcpTestSucceeded)\"",
          "    } catch {",
          "        Write-Output \"$endpoint : FAILED\"",
          "    }",
          "}",
          "# Reset network stack if issues detected",
          "Write-Output 'Resetting network stack...'",
          "netsh winsock reset",
          "netsh int ip reset",
          "# Restart Windows Update service",
          "Write-Output 'Restarting Windows Update service...'",
          "try {",
          "    Restart-Service -Name 'wuauserv' -Force -ErrorAction Stop",
          "    Write-Output 'Windows Update service restarted successfully'",
          "} catch {",
          "    Write-Output 'Failed to restart Windows Update service'",
          "}",
          "Write-Output 'Windows network troubleshooting completed'"
        ]
      }
    },
    {
      "action": "aws:runShellScript",
      "name": "LinuxNetworkTroubleshooting",
      "precondition": {
        "StringEquals": ["platformType", "Linux"]
      },
      "inputs": {
        "timeoutSeconds": "{{ executionTimeout }}",
        "runCommand": [
          "#!/bin/bash",
          "echo 'Starting Linux network troubleshooting for patch remediation'",
          "# Test basic connectivity",
          "echo 'Testing basic connectivity...'",
          "if ping -c 3 8.8.8.8 >/dev/null 2>&1; then",
          "    echo 'Basic connectivity to 8.8.8.8: OK'",
          "else",
          "    echo 'Basic connectivity to 8.8.8.8: FAILED'",
          "fi",
          "# Test DNS resolution", 
          "echo 'Testing DNS resolution...'",
          "if nslookup google.com >/dev/null 2>&1; then",
          "    echo 'DNS resolution: OK'",
          "else",
          "    echo 'DNS resolution: FAILED'",
          "    # Try to restart network services",
          "    echo 'Attempting to restart network services...'",
          "    systemctl restart systemd-resolved 2>/dev/null || true",
          "    sleep 5",
          "    if nslookup google.com >/dev/null 2>&1; then",
          "        echo 'DNS resolution after restart: OK'",
          "    else",
          "        echo 'DNS resolution still failing'",
          "    fi",
          "fi",
          "# Test repository connectivity",
          "echo 'Testing repository connectivity...'",
          "# Test common repository endpoints",
          "REPO_ENDPOINTS=(",
          "    'repo.us-east-1.amazonaws.com'",
          "    'amazonlinux.default.amazonaws.com'",
          "    'rhui-1.microsoft.com'",
          "    'archive.ubuntu.com'",
          ")",
          "for endpoint in \"${REPO_ENDPOINTS[@]}\"; do",
          "    if curl -I --connect-timeout 10 \"https://$endpoint\" >/dev/null 2>&1; then",
          "        echo \"$endpoint: OK\"",
          "    elif curl -I --connect-timeout 10 \"http://$endpoint\" >/dev/null 2>&1; then",
          "        echo \"$endpoint: OK (HTTP)\"",
          "    else",
          "        echo \"$endpoint: FAILED\"",
          "    fi",
          "done",
          "# Check and restart network services if needed",
          "echo 'Checking network services...'",
          "NETWORK_SERVICES=('networking' 'network' 'NetworkManager')",
          "for service in \"${NETWORK_SERVICES[@]}\"; do",
          "    if systemctl is-active --quiet \"$service\" 2>/dev/null; then",
          "        echo \"$service: ACTIVE\"",
          "    elif systemctl list-unit-files --type=service | grep -q \"^$service.service\"; then",
          "        echo \"$service: INACTIVE - attempting restart...\"",
          "        systemctl restart \"$service\" 2>/dev/null || true",
          "    fi",
          "done",
          "# Clear any cached package manager data",
          "echo 'Clearing package manager cache...'",
          "if command -v yum &> /dev/null; then",
          "    yum clean all 2>/dev/null || true",
          "    yum makecache fast 2>/dev/null || true",
          "elif command -v apt-get &> /dev/null; then",
          "    apt-get clean 2>/dev/null || true",
          "    apt-get update 2>/dev/null || true",
          "fi",
          "echo 'Linux network troubleshooting completed'"
        ]
      }
    }
  ]
}
5. CrossPlatformSSMAgentRecovery
json
{
  "schemaVersion": "2.2", 
  "description": "Cross-platform SSM agent recovery for patch remediation",
  "parameters": {
    "executionTimeout": {
      "type": "String",
      "default": "1800",
      "description": "Timeout for command execution"
    }
  },
  "mainSteps": [
    {
      "action": "aws:runPowerShellScript",
      "name": "WindowsSSMAgentRecovery",
      "precondition": {
        "StringEquals": ["platformType", "Windows"]
      },
      "inputs": {
        "timeoutSeconds": "{{ executionTimeout }}",
        "runCommand": [
          "Write-Output 'Starting Windows SSM agent recovery'",
          "# Check current agent status",
          "$service = Get-Service -Name 'AmazonSSMAgent' -ErrorAction SilentlyContinue",
          "if ($service) {",
          "    Write-Output \"Current SSM Agent status: $($service.Status)\"",
          "} else {",
          "    Write-Output 'SSM Agent service not found'",
          "    exit 1",
          "}",
          "# Stop the agent if running",
          "if ($service.Status -eq 'Running') {",
          "    try {",
          "        Stop-Service -Name 'AmazonSSMAgent' -Force -ErrorAction Stop",
          "        Write-Output 'SSM Agent stopped successfully'",
          "    } catch {",
          "        Write-Output \"Failed to stop SSM Agent: $($_.Exception.Message)\"",
          "    }",
          "}",
          "# Wait before restart",
          "Start-Sleep -Seconds 10",
          "# Restart the SSM Agent",
          "try {",
          "    Start-Service -Name 'AmazonSSMAgent' -ErrorAction Stop",
          "    Write-Output 'SSM Agent started successfully'",
          "} catch {",
          "    Write-Output \"Failed to start SSM Agent: $($_.Exception.Message)\"",
          "    exit 1",
          "}",
          "# Wait for agent to initialize",
          "Start-Sleep -Seconds 15",
          "# Verify agent is running and responsive",
          "$finalService = Get-Service -Name 'AmazonSSMAgent'",
          "Write-Output \"Final SSM Agent status: $($finalService.Status)\"",
          "if ($finalService.Status -eq 'Running') {",
          "    Write-Output 'SSM Agent recovery completed successfully'",
          "    # Test agent responsiveness",
          "    Write-Output 'Testing agent responsiveness...'",
          "    $agentStatus = & 'C:\\Program Files\\Amazon\\SSM\\amazon-ssm-agent.exe' -status 2>$null",
          "    if ($LASTEXITCODE -eq 0) {",
          "        Write-Output 'SSM Agent is responsive'",
          "    } else {",
          "        Write-Output 'SSM Agent may not be fully responsive'",
          "    }",
          "} else {",
          "    Write-Output 'SSM Agent recovery failed'",
          "    exit 1",
          "}"
        ]
      }
    },
    {
      "action": "aws:runShellScript",
      "name": "LinuxSSMAgentRecovery",
      "precondition": {
        "StringEquals": ["platformType", "Linux"]
      },
      "inputs": {
        "timeoutSeconds": "{{ executionTimeout }}",
        "runCommand": [
          "#!/bin/bash",
          "echo 'Starting Linux SSM agent recovery'",
          "# Check if SSM agent service exists",
          "if ! systemctl list-unit-files --type=service | grep -q 'amazon-ssm-agent.service'; then",
          "    echo 'ERROR: SSM Agent service not found'",
          "    exit 1",
          "fi",
          "# Check current agent status",
          "if systemctl is-active --quiet amazon-ssm-agent; then",
          "    echo 'SSM Agent is currently running'",
          "    AGENT_RUNNING=true",
          "else",
          "    echo 'SSM Agent is currently stopped'",
          "    AGENT_RUNNING=false",
          "fi",
          "# Stop the agent if running",
          "if [ \"$AGENT_RUNNING\" = true ]; then",
          "    echo 'Stopping SSM Agent...'",
          "    if sudo systemctl stop amazon-ssm-agent; then",
          "        echo 'SSM Agent stopped successfully'",
          "    else",
          "        echo 'Failed to stop SSM Agent'",
          "    fi",
          "fi",
          "# Wait before restart",
          "sleep 10",
          "# Start the SSM Agent",
          "echo 'Starting SSM Agent...'",
          "if sudo systemctl start amazon-ssm-agent; then",
          "    echo 'SSM Agent started successfully'",
          "else",
          "    echo 'Failed to start SSM Agent'",
          "    exit 1",
          "fi",
          "# Wait for agent to initialize",
          "sleep 15",
          "# Verify agent is running",
          "if systemctl is-active --quiet amazon-ssm-agent; then",
          "    echo 'SSM Agent is now running'",
          "else",
          "    echo 'SSM Agent failed to start properly'",
          "    exit 1",
          "fi",
          "# Show detailed status",
          "echo 'SSM Agent status:'",
          "sudo systemctl status amazon-ssm-agent --no-pager -l",
          "# Check agent logs for any errors",
          "echo 'Recent SSM Agent logs:'",
          "sudo journalctl -u amazon-ssm-agent --no-pager -n 10",
          "# Test agent responsiveness",
          "echo 'Testing agent responsiveness...'",
          "if sudo /usr/bin/amazon-ssm-agent -version >/dev/null 2>&1; then",
          "    echo 'SSM Agent is responsive'",
          "else",
          "    echo 'SSM Agent may not be fully responsive'",
          "fi",
          "echo 'Linux SSM agent recovery completed'"
        ]
      }
    }
  ]
}
CloudFormation Template Addition
Add this to your CloudFormation template to create all SSM documents:

text
Resources:
  # ... existing resources ...

  # SSM Document - Cross Platform Disk Cleanup
  CrossPlatformDiskCleanupDocument:
    Type: AWS::SSM::Document
    Properties:
      Name: CrossPlatformDiskCleanup
      DocumentType: Command
      DocumentFormat: JSON
      Content: 
        # Insert the CrossPlatformDiskCleanup JSON here

  # SSM Document - Cross Platform Service Management  
  CrossPlatformServiceManagementDocument:
    Type: AWS::SSM::Document
    Properties:
      Name: CrossPlatformServiceManagement
      DocumentType: Command
      DocumentFormat: JSON
      Content:
        # Insert the CrossPlatformServiceManagement JSON here

  # SSM Document - Cross Platform Service Restart
  CrossPlatformServiceRestartDocument:
    Type: AWS::SSM::Document
    Properties:
      Name: CrossPlatformServiceRestart
      DocumentType: Command
      DocumentFormat: JSON
      Content:
        # Insert the CrossPlatformServiceRestart JSON here

  # SSM Document - Cross Platform Network Troubleshooting
  CrossPlatformNetworkTroubleshootingDocument:
    Type: AWS::SSM::Document
    Properties:
      Name: CrossPlatformNetworkTroubleshooting
      DocumentType: Command
      DocumentFormat: JSON
      Content:
        # Insert the CrossPlatformNetworkTroubleshooting JSON here

  # SSM Document - Cross Platform SSM Agent Recovery
  CrossPlatformSSMAgentRecoveryDocument:
    Type: AWS::SSM::Document
    Properties:
      Name: CrossPlatformSSMAgentRecovery
      DocumentType: Command
      DocumentFormat: JSON
      Content:
        # Insert the CrossPlatformSSMAgentRecovery JSON here
CLI Deployment Commands
You can also create these documents via AWS CLI:

bash
# Create all SSM documents
aws ssm create-document --name "CrossPlatformDiskCleanup" --document-type "Command" --document-format JSON --content file://CrossPlatformDiskCleanup.json

aws ssm create-document --name "CrossPlatformServiceManagement" --document-type "Command" --document-format JSON --content file://CrossPlatformServiceManagement.json

aws ssm create-document --name "CrossPlatformServiceRestart" --document-type "Command" --document-format JSON --content file://CrossPlatformServiceRestart.json

aws ssm create-document --name "CrossPlatformNetworkTroubleshooting" --document-type "Command" --document-format JSON --content file://CrossPlatformNetworkTroubleshooting.json

aws ssm create-document --name "CrossPlatformSSMAgentRecovery" --document-type "Command" --document-format JSON --content file://CrossPlatformSSMAgentRecovery.json
Summary
âœ… Required Actions:

Create 5 new SSM documents (provided above)

No changes needed to existing AWS-RunPatchBaseline document

No changes needed to your existing maintenance windows

ðŸŽ¯ Key Features:

Cross-platform compatibility using precondition checks

Error handling with comprehensive try-catch blocks

Service tracking to restart only services that were stopped

Comprehensive logging for troubleshooting

Timeout protection with configurable execution timeouts

These SSM documents are essential for the automation to work - the Step Functions will fail if they try to execute non-existent documents!