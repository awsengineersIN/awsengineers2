import json
import boto3
import logging
import os
from datetime import datetime

logger = logging.getLogger()
logger.setLevel(logging.INFO)

bedrock_runtime = boto3.client('bedrock-runtime')
support = boto3.client('support', region_name='us-east-1')
ssm = boto3.client('ssm')
ec2 = boto3.client('ec2')
dynamodb = boto3.resource('dynamodb')

def lambda_handler(event, context):
    """
    Creates intelligent AWS support tickets using Bedrock when automated remediation fails
    Updates DynamoDB with ticket information
    """
    try:
        # Handle both direct invocation and Step Functions payload
        if 'Payload' in event:
            payload = event['Payload']
        else:
            payload = event
            
        instance_id = payload.get('instance_id')
        remediation_plan = payload.get('remediation_plan', {})
        maintenance_window_id = payload.get('maintenance_window_id')
        failure_context = payload.get('failure_context', {})
        tracking_id = payload.get('tracking_id')
        
        logger.info(f"Creating support ticket for failed remediation on instance {instance_id}")
        
        # Gather comprehensive failure context
        ticket_context = gather_failure_context(instance_id, remediation_plan, maintenance_window_id, failure_context)
        
        # Use Bedrock to generate intelligent ticket content
        ticket_content = generate_ticket_content_with_bedrock(ticket_context)
        
        # Create AWS support ticket
        ticket_response = create_support_ticket(ticket_content, instance_id)
        
        # Update DynamoDB with ticket information
        if tracking_id:
            update_tracking_record_with_ticket(tracking_id, ticket_response, ticket_content)
        
        logger.info(f"Support ticket created: {ticket_response}")
        
        return {
            'Payload': {
                'support_ticket_created': True,
                'ticket_id': ticket_response.get('caseId'),
                'ticket_status': 'created',
                'instance_id': instance_id,
                'bedrock_analysis': {
                    'title': ticket_content.get('title'),
                    'severity': ticket_content.get('severity'),
                    'summary': ticket_content.get('summary'),
                    'bedrock_generated': ticket_content.get('bedrock_generated', False)
                },
                'tracking_id': tracking_id
            }
        }
        
    except Exception as e:
        logger.error(f"Error creating support ticket: {str(e)}")
        # Update tracking record with error
        if payload.get('tracking_id'):
            update_tracking_record_with_error(payload.get('tracking_id'), str(e))
        
        return {
            'Payload': {
                'support_ticket_created': False,
                'error': str(e),
                'instance_id': payload.get('instance_id', 'Unknown'),
                'tracking_id': payload.get('tracking_id')
            }
        }

def gather_failure_context(instance_id, remediation_plan, maintenance_window_id, failure_context):
    """Gather comprehensive context about the failure for Bedrock analysis"""
    try:
        context = {
            'instance_id': instance_id,
            'timestamp': datetime.utcnow().isoformat(),
            'remediation_plan': remediation_plan,
            'maintenance_window_id': maintenance_window_id,
            'failure_context': failure_context
        }
        
        # Get instance details
        try:
            instance_info = ec2.describe_instances(InstanceIds=[instance_id])
            if instance_info.get('Reservations') and instance_info['Reservations'][0].get('Instances'):
                instance = instance_info['Reservations'][0]['Instances'][0]
                context['instance_details'] = {
                    'platform': instance.get('Platform', 'Linux'),
                    'instance_type': instance.get('InstanceType'),
                    'vpc_id': instance.get('VpcId'),
                    'subnet_id': instance.get('SubnetId'),
                    'availability_zone': instance.get('Placement', {}).get('AvailabilityZone'),
                    'launch_time': str(instance.get('LaunchTime', '')),
                    'state': instance.get('State', {}).get('Name'),
                    'ami_id': instance.get('ImageId'),
                    'security_groups': [sg['GroupId'] for sg in instance.get('SecurityGroups', [])]
                }
        except Exception as e:
            logger.warning(f"Could not get instance details: {str(e)}")
            context['instance_details'] = {'error': str(e)}
        
        # Get recent patch compliance history
        try:
            patch_states = ssm.describe_instance_patch_states(InstanceIds=[instance_id])
            if patch_states.get('InstancePatchStates'):
                patch_state = patch_states['InstancePatchStates'][0]
                context['patch_compliance'] = {
                    'failed_count': patch_state.get('FailedCount', 0),
                    'installed_count': patch_state.get('InstalledCount', 0),
                    'missing_count': patch_state.get('MissingCount', 0),
                    'not_applicable_count': patch_state.get('NotApplicableCount', 0),
                    'operation_end_time': str(patch_state.get('OperationEndTime', '')),
                    'operation': patch_state.get('Operation'),
                    'patch_group': patch_state.get('PatchGroup')
                }
        except Exception as e:
            logger.warning(f"Could not get patch compliance: {str(e)}")
            context['patch_compliance'] = {'error': str(e)}
        
        # Get recent command executions
        try:
            recent_commands = ssm.list_command_invocations(
                InstanceId=instance_id,
                MaxResults=5
            )
            context['recent_commands'] = []
            for cmd in recent_commands.get('CommandInvocations', []):
                context['recent_commands'].append({
                    'command_id': cmd.get('CommandId'),
                    'document_name': cmd.get('DocumentName'),
                    'status': cmd.get('Status'),
                    'requested_date_time': str(cmd.get('RequestedDateTime', '')),
                    'status_details': cmd.get('StatusDetails', ''),
                    'standard_error_content': cmd.get('StandardErrorContent', '')[:500]
                })
        except Exception as e:
            logger.warning(f"Could not get recent commands: {str(e)}")
            context['recent_commands'] = [{'error': str(e)}]
        
        return context
        
    except Exception as e:
        logger.error(f"Error gathering failure context: {str(e)}")
        return {'error': str(e), 'instance_id': instance_id}

def generate_ticket_content_with_bedrock(context):
    """Use Bedrock to generate intelligent support ticket content"""
    try:
        prompt = create_bedrock_prompt(context)
        
        model_id = os.environ.get('BEDROCK_MODEL_ID', 'anthropic.claude-3-sonnet-20240229-v1:0')
        
        body = {
            "anthropic_version": "bedrock-2023-05-31",
            "max_tokens": 2000,
            "messages": [
                {
                    "role": "user",
                    "content": prompt
                }
            ],
            "temperature": 0.1
        }
        
        response = bedrock_runtime.invoke_model(
            modelId=model_id,
            body=json.dumps(body)
        )
        
        response_body = json.loads(response['body'].read())
        ticket_content = response_body['content'][0]['text']
        
        parsed_content = parse_bedrock_response(ticket_content, context)
        
        logger.info("Successfully generated ticket content with Bedrock")
        return parsed_content
        
    except Exception as e:
        logger.error(f"Error generating content with Bedrock: {str(e)}")
        return create_fallback_ticket_content(context)

def create_bedrock_prompt(context):
    """Create a comprehensive prompt for Bedrock analysis"""
    
    prompt = f"""
You are an AWS Technical Support specialist analyzing a failed automated patch remediation for an EC2 instance. 
Based on the following context, create a comprehensive support ticket that will help AWS Support engineers quickly understand and resolve the issue.

FAILURE CONTEXT:
Instance ID: {context.get('instance_id')}
Platform: {context.get('instance_details', {}).get('platform', 'Unknown')}
Instance Type: {context.get('instance_details', {}).get('instance_type', 'Unknown')}
Remediation Strategy Attempted: {context.get('remediation_plan', {}).get('strategy', 'Unknown')}
Confidence Score: {context.get('remediation_plan', {}).get('confidence_score', 'Unknown')}
Maintenance Window ID: {context.get('maintenance_window_id')}

INSTANCE DETAILS:
{json.dumps(context.get('instance_details', {}), indent=2)}

PATCH COMPLIANCE STATUS:
{json.dumps(context.get('patch_compliance', {}), indent=2)}

RECENT COMMAND EXECUTIONS:
{json.dumps(context.get('recent_commands', []), indent=2)}

FAILURE ANALYSIS:
{json.dumps(context.get('failure_context', {}), indent=2)}

REMEDIATION PLAN DETAILS:
{json.dumps(context.get('remediation_plan', {}), indent=2)}

ML INSIGHTS (if available):
{json.dumps(context.get('remediation_plan', {}).get('ml_insights', {}), indent=2)}

Please provide a structured response in the following format:

**TICKET_TITLE:**
[Concise, descriptive title for the support ticket]

**SEVERITY:**
[LOW/NORMAL/HIGH/URGENT based on the impact assessment]

**SUMMARY:**
[Brief 2-3 sentence summary of the issue]

**PROBLEM_DESCRIPTION:**
[Detailed description of what happened, when it happened, and current impact]

**TECHNICAL_ANALYSIS:**
[Your analysis of the root cause based on the error patterns, logs, and system state]

**ATTEMPTED_SOLUTIONS:**
[List of automated remediation steps that were already tried]

**RECOMMENDED_ACTIONS:**
[Specific recommendations for AWS Support engineers, including what to investigate first]

**ADDITIONAL_CONTEXT:**
[Any other relevant technical details that would help in troubleshooting]

Focus on being technical, specific, and actionable. Include specific error messages, timing information, and technical details that would help a support engineer quickly understand and resolve the issue.
"""
    
    return prompt

def parse_bedrock_response(bedrock_response, context):
    """Parse the structured Bedrock response into ticket components"""
    try:
        sections = {}
        current_section = None
        
        for line in bedrock_response.split('\n'):
            line = line.strip()
            if line.startswith('**') and line.endswith(':**'):
                current_section = line[2:-3].lower()
                sections[current_section] = ""
            elif current_section and line:
                sections[current_section] += line + "\n"
        
        for key in sections:
            sections[key] = sections[key].strip()
        
        return {
            'title': sections.get('ticket_title', f"Automated Patch Remediation Failed - {context.get('instance_id')}"),
            'severity': sections.get('severity', 'NORMAL').upper(),
            'summary': sections.get('summary', 'Automated patch remediation failed after multiple attempts'),
            'description': sections.get('problem_description', ''),
            'technical_analysis': sections.get('technical_analysis', ''),
            'attempted_solutions': sections.get('attempted_solutions', ''),
            'recommended_actions': sections.get('recommended_actions', ''),
            'additional_context': sections.get('additional_context', ''),
            'bedrock_generated': True
        }
        
    except Exception as e:
        logger.warning(f"Error parsing Bedrock response: {str(e)}")
        return create_fallback_ticket_content(context)

def create_fallback_ticket_content(context):
    """Create fallback ticket content if Bedrock fails"""
    instance_id = context.get('instance_id', 'Unknown')
    platform = context.get('instance_details', {}).get('platform', 'Unknown')
    strategy = context.get('remediation_plan', {}).get('strategy', 'Unknown')
    
    return {
        'title': f"Automated Patch Remediation Failed - Instance {instance_id}",
        'severity': 'NORMAL',
        'summary': f'Automated patch remediation failed on {platform} instance {instance_id} using {strategy} strategy',
        'description': f'''
INSTANCE: {instance_id}
PLATFORM: {platform}
STRATEGY ATTEMPTED: {strategy}
TIMESTAMP: {context.get('timestamp')}

The automated patch remediation system attempted to fix patch failures but was unsuccessful.

FAILURE CONTEXT:
{json.dumps(context.get('failure_context', {}), indent=2)}

REMEDIATION PLAN:
{json.dumps(context.get('remediation_plan', {}), indent=2)}

Please investigate the root cause and provide guidance for manual remediation.
        ''',
        'technical_analysis': 'Generated by fallback template - Bedrock analysis unavailable',
        'attempted_solutions': f'Automated {strategy} remediation was attempted but failed',
        'recommended_actions': 'Please review instance logs and patch compliance status for manual troubleshooting',
        'additional_context': json.dumps(context, indent=2),
        'bedrock_generated': False
    }

def create_support_ticket(ticket_content, instance_id):
    """Create AWS support ticket using the Support API"""
    try:
        create_actual_tickets = os.environ.get('CREATE_ACTUAL_TICKETS', 'false').lower() == 'true'
        
        if not create_actual_tickets:
            logger.info("CREATE_ACTUAL_TICKETS is false - simulating ticket creation")
            return simulate_ticket_creation(ticket_content, instance_id)
        
        support_plan = get_support_plan()
        
        if not support_plan:
            logger.warning("No AWS Support plan or insufficient permissions - simulating ticket creation")
            return simulate_ticket_creation(ticket_content, instance_id)
        
        severity_mapping = {
            'LOW': 'low',
            'NORMAL': 'normal', 
            'HIGH': 'high',
            'URGENT': 'urgent'
        }
        
        severity = severity_mapping.get(ticket_content.get('severity', 'NORMAL'), 'normal')
        
        full_description = f"""
{ticket_content.get('summary', '')}

PROBLEM DESCRIPTION:
{ticket_content.get('description', '')}

TECHNICAL ANALYSIS:
{ticket_content.get('technical_analysis', '')}

ATTEMPTED SOLUTIONS:
{ticket_content.get('attempted_solutions', '')}

RECOMMENDED ACTIONS:
{ticket_content.get('recommended_actions', '')}

ADDITIONAL CONTEXT:
{ticket_content.get('additional_context', '')}

---
This ticket was automatically generated by the Self-Healing Patch Management System.
Generated with: {'Amazon Bedrock' if ticket_content.get('bedrock_generated') else 'Template Fallback'}
Instance ID: {instance_id}
Timestamp: {datetime.utcnow().isoformat()}
        """
        
        response = support.create_case(
            subject=ticket_content.get('title', f'Patch Remediation Failed - {instance_id}'),
            serviceCode='amazon-elastic-compute-cloud-linux',
            severityCode=severity,
            categoryCode='instance-issue',
            communicationBody=full_description,
            ccEmailAddresses=[],
            language='en',
            issueType='technical'
        )
        
        logger.info(f"Successfully created support ticket: {response.get('caseId')}")
        return response
        
    except Exception as e:
        logger.error(f"Error creating support ticket: {str(e)}")
        return simulate_ticket_creation(ticket_content, instance_id)

def get_support_plan():
    """Check if AWS Support plan allows ticket creation"""
    try:
        response = support.describe_supported_languages()
        return True
    except Exception as e:
        logger.warning(f"Support API not available: {str(e)}")
        return False

def simulate_ticket_creation(ticket_content, instance_id):
    """Simulate ticket creation when Support API is not available"""
    import uuid
    
    simulated_case_id = f"case-sim-{str(uuid.uuid4())[:8]}"
    
    logger.info(f"SIMULATED SUPPORT TICKET CREATION:")
    logger.info(f"Case ID: {simulated_case_id}")
    logger.info(f"Title: {ticket_content.get('title')}")
    logger.info(f"Severity: {ticket_content.get('severity')}")
    logger.info(f"Instance: {instance_id}")
    logger.info("Note: This is a simulation - no actual ticket was created")
    
    return {
        'caseId': simulated_case_id,
        'simulated': True,
        'status': 'created'
    }

def update_tracking_record_with_ticket(tracking_id, ticket_response, ticket_content):
    """Update DynamoDB tracking record with support ticket information"""
    try:
        table_name = os.environ.get('DYNAMODB_TABLE_NAME', f'patch-tracking-{os.environ.get("ENVIRONMENT", "prod")}')
        table = dynamodb.Table(table_name)
        
        # Find the record by tracking_id using GSI
        response = table.query(
            IndexName='tracking-id-index',
            KeyConditionExpression='tracking_id = :tracking_id',
            ExpressionAttributeValues={':tracking_id': tracking_id}
        )
        
        if response.get('Items'):
            item = response['Items'][0]
            instance_id = item['instance_id']
            timestamp = item['timestamp']
            
            # Update the record with ticket information
            table.update_item(
                Key={'instance_id': instance_id, 'timestamp': timestamp},
                UpdateExpression='SET #st = :status, support_ticket_id = :ticket_id, support_ticket_created = :created, bedrock_analysis = :analysis, updated_at = :updated',
                ExpressionAttributeNames={'#st': 'status'},
                ExpressionAttributeValues={
                    ':status': 'support_ticket_created',
                    ':ticket_id': ticket_response.get('caseId'),
                    ':created': datetime.utcnow().isoformat(),
                    ':analysis': json.dumps(ticket_content, default=str),
                    ':updated': datetime.utcnow().isoformat()
                }
            )
            
            logger.info(f"Updated tracking record {tracking_id} with ticket information")
        
    except Exception as e:
        logger.error(f"Error updating tracking record with ticket info: {str(e)}")

def update_tracking_record_with_error(tracking_id, error_message):
    """Update DynamoDB tracking record with error information"""
    try:
        table_name = os.environ.get('DYNAMODB_TABLE_NAME', f'patch-tracking-{os.environ.get("ENVIRONMENT", "prod")}')
        table = dynamodb.Table(table_name)
        
        response = table.query(
            IndexName='tracking-id-index',
            KeyConditionExpression='tracking_id = :tracking_id',
            ExpressionAttributeValues={':tracking_id': tracking_id}
        )
        
        if response.get('Items'):
            item = response['Items'][0]
            instance_id = item['instance_id']
            timestamp = item['timestamp']
            
            table.update_item(
                Key={'instance_id': instance_id, 'timestamp': timestamp},
                UpdateExpression='SET #st = :status, ticket_creation_error = :error, updated_at = :updated',
                ExpressionAttributeNames={'#st': 'status'},
                ExpressionAttributeValues={
                    ':status': 'ticket_creation_failed',
                    ':error': error_message,
                    ':updated': datetime.utcnow().isoformat()
                }
            )
        
    except Exception as e:
        logger.error(f"Error updating tracking record with error: {str(e)}")
