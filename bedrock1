import json
import boto3
import logging
import os
from datetime import datetime
import uuid

# Configure logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Initialize AWS clients
bedrock_runtime = boto3.client('bedrock-runtime')
support = boto3.client('support', region_name='us-east-1')  # Support API only in us-east-1
ssm = boto3.client('ssm')
ec2 = boto3.client('ec2')

def lambda_handler(event, context):
    """
    Create intelligent AWS Support tickets using Amazon Bedrock
    
    Triggered by Step Functions when automated remediation fails
    
    This function:
    1. Gathers comprehensive failure context
    2. Uses Bedrock to generate intelligent ticket content
    3. Creates actual AWS Support ticket (or simulates if not available)
    4. Returns ticket details for notification
    
    No existing resources are modified - only creates new support tickets
    """
    try:
        # Extract input parameters
        instance_id = event.get('instance_id')
        remediation_plan = event.get('remediation_plan', {})
        maintenance_window_id = event.get('maintenance_window_id')
        
        if not instance_id:
            raise ValueError("instance_id is required but was not provided")
        
        logger.info(f"=== CREATING SUPPORT TICKET ===")
        logger.info(f"Instance: {instance_id}")
        logger.info(f"Failed Strategy: {remediation_plan.get('strategy', 'Unknown')}")
        logger.info(f"Platform: {remediation_plan.get('platform', 'Unknown')}")
        
        # Step 1: Gather comprehensive context about the failure
        logger.info("üìä Gathering failure context...")
        failure_context = gather_comprehensive_failure_context(
            instance_id, remediation_plan, maintenance_window_id
        )
        
        # Step 2: Use Bedrock to generate intelligent ticket content
        logger.info("ü§ñ Generating ticket content with Amazon Bedrock...")
        ticket_content = generate_bedrock_ticket_content(failure_context)
        
        # Step 3: Create the actual AWS Support ticket
        logger.info("üé´ Creating AWS Support ticket...")
        ticket_response = create_aws_support_ticket(ticket_content, instance_id)
        
        # Step 4: Prepare response
        response = {
            'support_ticket_created': True,
            'ticket_id': ticket_response.get('caseId'),
            'ticket_simulated': ticket_response.get('simulated', False),
            'instance_id': instance_id,
            'ticket_details': {
                'title': ticket_content.get('title'),
                'severity': ticket_content.get('severity'),
                'summary': ticket_content.get('summary'),
                'bedrock_generated': ticket_content.get('bedrock_generated', False)
            },
            'created_timestamp': datetime.utcnow().isoformat()
        }
        
        logger.info(f"‚úÖ Support ticket created successfully")
        logger.info(f"   Ticket ID: {response['ticket_id']}")
        logger.info(f"   Severity: {ticket_content.get('severity')}")
        logger.info(f"   Simulated: {response['ticket_simulated']}")
        
        return response
        
    except Exception as e:
        logger.error(f"‚ùå Error creating support ticket: {str(e)}")
        
        # Return error response but don't raise exception (let Step Functions handle it)
        return {
            'support_ticket_created': False,
            'error': str(e),
            'instance_id': event.get('instance_id', 'Unknown'),
            'error_timestamp': datetime.utcnow().isoformat()
        }

def gather_comprehensive_failure_context(instance_id, remediation_plan, maintenance_window_id):
    """
    Gather all available context about the failure for Bedrock analysis
    
    Args:
        instance_id: Failed EC2 instance
        remediation_plan: What remediation was attempted
        maintenance_window_id: Original maintenance window
        
    Returns:
        dict: Comprehensive failure context for Bedrock
        
    Note: Only reads existing data - no modifications to any resources
    """
    try:
        context = {
            'instance_id': instance_id,
            'remediation_plan': remediation_plan,
            'maintenance_window_id': maintenance_window_id,
            'analysis_timestamp': datetime.utcnow().isoformat()
        }
        
        # Get detailed instance information
        logger.info("  üìã Getting EC2 instance details...")
        try:
            ec2_response = ec2.describe_instances(InstanceIds=[instance_id])
            
            if ec2_response.get('Reservations') and ec2_response['Reservations'][0].get('Instances'):
                instance = ec2_response['Reservations'][0]['Instances'][0]
                context['instance_details'] = {
                    'platform': instance.get('Platform', 'Linux'),
                    'instance_type': instance.get('InstanceType'),
                    'availability_zone': instance.get('Placement', {}).get('AvailabilityZone'),
                    'subnet_id': instance.get('SubnetId'),
                    'vpc_id': instance.get('VpcId'),
                    'ami_id': instance.get('ImageId'),
                    'launch_time': str(instance.get('LaunchTime', '')),
                    'instance_state': instance.get('State', {}).get('Name'),
                    'security_groups': [sg['GroupId'] for sg in instance.get('SecurityGroups', [])]
                }
                logger.info(f"    ‚úì Instance type: {context['instance_details']['instance_type']}")
                logger.info(f"    ‚úì Platform: {context['instance_details']['platform']}")
                
        except Exception as e:
            logger.warning(f"  ‚ö†Ô∏è  Could not get instance details: {str(e)}")
            context['instance_details'] = {'error': f'Could not retrieve: {str(e)}'}
        
        # Get current patch compliance status
        logger.info("  ü©π Getting patch compliance status...")
        try:
            patch_response = ssm.describe_instance_patch_states(InstanceIds=[instance_id])
            
            if patch_response.get('InstancePatchStates'):
                patch_state = patch_response['InstancePatchStates'][0]
                context['patch_compliance'] = {
                    'failed_count': patch_state.get('FailedCount', 0),
                    'installed_count': patch_state.get('InstalledCount', 0),
                    'missing_count': patch_state.get('MissingCount', 0),
                    'not_applicable_count': patch_state.get('NotApplicableCount', 0),
                    'operation_end_time': str(patch_state.get('OperationEndTime', '')),
                    'operation_type': patch_state.get('Operation'),
                    'patch_group': patch_state.get('PatchGroup'),
                    'baseline_id': patch_state.get('BaselineId')
                }
                logger.info(f"    ‚úì Failed patches: {context['patch_compliance']['failed_count']}")
                logger.info(f"    ‚úì Missing patches: {context['patch_compliance']['missing_count']}")
                
        except Exception as e:
            logger.warning(f"  ‚ö†Ô∏è  Could not get patch compliance: {str(e)}")
            context['patch_compliance'] = {'error': f'Could not retrieve: {str(e)}'}
        
        # Get recent SSM command history
        logger.info("  üìú Getting recent SSM command history...")
        try:
            commands_response = ssm.list_command_invocations(
                InstanceId=instance_id,
                MaxResults=5  # Last 5 commands
            )
            
            context['recent_commands'] = []
            for cmd in commands_response.get('CommandInvocations', []):
                context['recent_commands'].append({
                    'command_id': cmd.get('CommandId'),
                    'document_name': cmd.get('DocumentName'),
                    'status': cmd.get('Status'),
                    'requested_time': str(cmd.get('RequestedDateTime', '')),
                    'status_details': cmd.get('StatusDetails', '')[:500],  # Truncate long details
                    'error_output': cmd.get('StandardErrorContent', '')[:500]  # Truncate errors
                })
                
            logger.info(f"    ‚úì Retrieved {len(context['recent_commands'])} recent commands")
            
        except Exception as e:
            logger.warning(f"  ‚ö†Ô∏è  Could not get command history: {str(e)}")
            context['recent_commands'] = [{'error': f'Could not retrieve: {str(e)}'}]
        
        logger.info("  ‚úÖ Context gathering completed")
        return context
        
    except Exception as e:
        logger.error(f"  ‚ùå Error gathering failure context: {str(e)}")
        return {
            'error': f'Context gathering failed: {str(e)}',
            'instance_id': instance_id
        }

def generate_bedrock_ticket_content(context):
    """
    Use Amazon Bedrock to generate intelligent support ticket content
    
    Args:
        context: Comprehensive failure context
        
    Returns:
        dict: Structured ticket content with title, description, etc.
    """
    try:
        # Create detailed prompt for Bedrock
        prompt = create_comprehensive_bedrock_prompt(context)
        
        # Get Bedrock model configuration
        model_id = os.environ.get('BEDROCK_MODEL_ID', 'anthropic.claude-3-sonnet-20240229-v1:0')
        
        # Prepare Bedrock request
        request_body = {
            "anthropic_version": "bedrock-2023-05-31",
            "max_tokens": 2000,
            "messages": [
                {
                    "role": "user",
                    "content": prompt
                }
            ],
            "temperature": 0.1  # Low temperature for consistent, factual output
        }
        
        # Call Bedrock
        bedrock_response = bedrock_runtime.invoke_model(
            modelId=model_id,
            body=json.dumps(request_body)
        )
        
        # Parse response
        response_body = json.loads(bedrock_response['body'].read())
        ai_generated_content = response_body['content'][0]['text']
        
        # Parse the structured response from Bedrock
        ticket_content = parse_bedrock_ticket_response(ai_generated_content, context)
        
        logger.info("  ü§ñ Successfully generated ticket content with Bedrock")
        logger.info(f"    ‚úì Title: {ticket_content.get('title', '')[:60]}...")
        logger.info(f"    ‚úì Severity: {ticket_content.get('severity')}")
        
        return ticket_content
        
    except Exception as e:
        logger.error(f"  ‚ùå Bedrock generation failed: {str(e)}")
        logger.info("  üîÑ Falling back to template-based ticket generation")
        
        # Fallback to simple template-based generation
        return generate_fallback_ticket_content(context)

def create_comprehensive_bedrock_prompt(context):
    """Create a detailed prompt for Bedrock to analyze the failure"""
    
    prompt = f"""
You are a senior AWS Technical Support engineer with expertise in EC2 patch management and troubleshooting. 

A customer's automated patch remediation system has failed, and you need to create a comprehensive support ticket that will help AWS Support engineers quickly understand and resolve the issue.

FAILURE SUMMARY:
Instance ID: {context.get('instance_id')}
Platform: {context.get('instance_details', {}).get('platform', 'Unknown')}
Instance Type: {context.get('instance_details', {}).get('instance_type', 'Unknown')}
Failed Remediation Strategy: {context.get('remediation_plan', {}).get('strategy', 'Unknown')}
Maintenance Window: {context.get('maintenance_window_id')}

INSTANCE DETAILS:
{json.dumps(context.get('instance_details', {}), indent=2)}

PATCH COMPLIANCE STATUS:
{json.dumps(context.get('patch_compliance', {}), indent=2)}

RECENT SSM COMMAND HISTORY:
{json.dumps(context.get('recent_commands', []), indent=2)}

ATTEMPTED REMEDIATION:
{json.dumps(context.get('remediation_plan', {}), indent=2)}

Please analyze this information and create a professional support ticket with the following structure:

**TITLE:**
[Create a concise, descriptive title that clearly identifies the issue]

**SEVERITY:**
[Choose: LOW, NORMAL, HIGH, or URGENT based on business impact]

**SUMMARY:**
[Write a 2-3 sentence executive summary of the problem]

**DETAILED_DESCRIPTION:**
[Provide a comprehensive technical description including:
- What happened and when
- Current system state
- Business impact
- Urgency factors]

**TECHNICAL_ANALYSIS:**
[Provide your expert analysis including:
- Root cause hypothesis based on the error patterns
- Why the automated remediation likely failed
- Technical factors that may be contributing]

**RECOMMENDED_ACTIONS:**
[List specific actions AWS Support should take:
- What to investigate first
- Specific logs or metrics to check
- Recommended solutions to try]

**ADDITIONAL_CONTEXT:**
[Include any other relevant technical details that would help in troubleshooting]

Focus on providing actionable, technical insights that will help AWS Support engineers resolve this quickly. Use your expertise to identify the most likely causes and solutions.
"""
    
    return prompt

def parse_bedrock_ticket_response(ai_response, context):
    """
    Parse the structured response from Bedrock into ticket components
    
    Args:
        ai_response: Raw text response from Bedrock
        context: Original failure context
        
    Returns:
        dict: Parsed ticket content
    """
    try:
        # Parse sections marked with **SECTION:** format
        sections = {}
        current_section = None
        
        for line in ai_response.split('\n'):
            line = line.strip()
            
            # Check for section headers
            if line.startswith('**') and line.endswith(':**'):
                section_name = line[2:-3].lower().replace('_', '')
                current_section = section_name
                sections[current_section] = ""
                
            # Add content to current section
            elif current_section and line:
                sections[current_section] += line + "\n"
        
        # Clean up sections
        for key in sections:
            sections[key] = sections[key].strip()
        
        # Build structured ticket content
        ticket_content = {
            'title': sections.get('title', f"Patch Remediation Failed - {context.get('instance_id')}"),
            'severity': sections.get('severity', 'NORMAL').upper(),
            'summary': sections.get('summary', 'Automated patch remediation failed after multiple attempts'),
            'description': sections.get('detaileddescription', sections.get('description', '')),
            'technical_analysis': sections.get('technicalanalysis', ''),
            'recommended_actions': sections.get('recommendedactions', ''),
            'additional_context': sections.get('additionalcontext', ''),
            'bedrock_generated': True,
            'generation_timestamp': datetime.utcnow().isoformat()
        }
        
        return ticket_content
        
    except Exception as e:
        logger.warning(f"  ‚ö†Ô∏è  Error parsing Bedrock response: {str(e)}")
        return generate_fallback_ticket_content(context)

def generate_fallback_ticket_content(context):
    """
    Generate basic ticket content when Bedrock is unavailable
    
    Args:
        context: Failure context
        
    Returns:
        dict: Basic ticket content
    """
    instance_id = context.get('instance_id', 'Unknown')
    platform = context.get('instance_details', {}).get('platform', 'Unknown')
    strategy = context.get('remediation_plan', {}).get('strategy', 'Unknown')
    
    return {
        'title': f"Automated Patch Remediation Failed - Instance {instance_id}",
        'severity': 'NORMAL',
        'summary': f'Automated patch remediation failed on {platform} instance {instance_id} using {strategy} strategy',
        'description': f"""
INSTANCE: {instance_id}
PLATFORM: {platform}
ATTEMPTED STRATEGY: {strategy}
TIMESTAMP: {context.get('analysis_timestamp')}

The automated patch remediation system attempted to resolve patch failures but was unsuccessful.

FAILURE CONTEXT:
{json.dumps(context.get('remediation_plan', {}), indent=2)}

INSTANCE DETAILS:
{json.dumps(context.get('instance_details', {}), indent=2)}

PATCH COMPLIANCE:
{json.dumps(context.get('patch_compliance', {}), indent=2)}

Please investigate the root cause and provide guidance for manual remediation.
        """,
        'technical_analysis': 'Generated using fallback template - Bedrock analysis was not available',
        'recommended_actions': 'Please review instance patch compliance status and SSM command history for troubleshooting',
        'additional_context': json.dumps(context, indent=2),
        'bedrock_generated': False,
        'generation_timestamp': datetime.utcnow().isoformat()
    }

def create_aws_support_ticket(ticket_content, instance_id):
    """
    Create actual AWS Support ticket or simulate if not available
    
    Args:
        ticket_content: Structured ticket content from Bedrock
        instance_id: EC2 instance ID
        
    Returns:
        dict: Ticket creation response
    """
    try:
        # Check if actual ticket creation is enabled
        create_real_tickets = os.environ.get('CREATE_ACTUAL_TICKETS', 'false').lower() == 'true'
        
        if not create_real_tickets:
            logger.info("  üîÑ CREATE_ACTUAL_TICKETS=false - simulating ticket creation")
            return simulate_ticket_creation(ticket_content, instance_id)
        
        # Check if Support API is available
        try:
            support.describe_supported_languages()
            logger.info("  ‚úì AWS Support API is available")
            
        except Exception as api_error:
            logger.warning(f"  ‚ö†Ô∏è  Support API not available: {str(api_error)}")
            logger.info("  üîÑ Falling back to simulated ticket creation")
            return simulate_ticket_creation(ticket_content, instance_id)
        
        # Map severity levels
        severity_mapping = {
            'LOW': 'low',
            'NORMAL': 'normal',
            'HIGH': 'high', 
            'URGENT': 'urgent'
        }
        
        severity = severity_mapping.get(
            ticket_content.get('severity', 'NORMAL').upper(), 
            'normal'
        )
        
        # Build complete ticket description
        full_description = create_complete_ticket_description(ticket_content, instance_id)
        
        # Create the support case
        response = support.create_case(
            subject=ticket_content.get('title', f'Patch Remediation Failed - {instance_id}'),
            serviceCode='amazon-elastic-compute-cloud-linux',
            severityCode=severity,
            categoryCode='instance-issue',
            communicationBody=full_description,
            ccEmailAddresses=[],
            language='en',
            issueType='technical'
        )
        
        logger.info(f"  ‚úÖ AWS Support ticket created successfully")
        logger.info(f"    Case ID: {response.get('caseId')}")
        
        return {
            'caseId': response.get('caseId'),
            'simulated': False,
            'status': 'created'
        }
        
    except Exception as e:
        logger.error(f"  ‚ùå Error creating support ticket: {str(e)}")
        logger.info("  üîÑ Falling back to simulated ticket creation")
        return simulate_ticket_creation(ticket_content, instance_id)

def create_complete_ticket_description(ticket_content, instance_id):
    """Build the complete ticket description"""
    
    return f"""
{ticket_content.get('summary', '')}

DETAILED DESCRIPTION:
{ticket_content.get('description', '')}

TECHNICAL ANALYSIS:
{ticket_content.get('technical_analysis', '')}

RECOMMENDED ACTIONS:
{ticket_content.get('recommended_actions', '')}

ADDITIONAL CONTEXT:
{ticket_content.get('additional_context', '')}

---
TICKET METADATA:
Generated by: Self-Healing Patch Management System
Instance ID: {instance_id}
Generation Method: {'Amazon Bedrock AI' if ticket_content.get('bedrock_generated') else 'Fallback Template'}
Created: {datetime.utcnow().isoformat()}
    """

def simulate_ticket_creation(ticket_content, instance_id):
    """
    Simulate ticket creation when real API is not available
    
    Args:
        ticket_content: Structured ticket content
        instance_id: EC2 instance ID
        
    Returns:
        dict: Simulated ticket response
    """
    # Generate realistic-looking case ID
    simulated_case_id = f"case-{str(uuid.uuid4())[:8]}"
    
    logger.info("  üé≠ SIMULATED SUPPORT TICKET CREATION")
    logger.info(f"    Simulated Case ID: {simulated_case_id}")
    logger.info(f"    Title: {ticket_content.get('title', '')[:60]}...")
    logger.info(f"    Severity: {ticket_content.get('severity')}")
    logger.info(f"    Instance: {instance_id}")
    logger.info(f"    AI Generated: {ticket_content.get('bedrock_generated', False)}")
    logger.info("    Note: This is a SIMULATION - no actual ticket was created")
    
    return {
        'caseId': simulated_case_id,
        'simulated': True,
        'status': 'simulated'
    }
