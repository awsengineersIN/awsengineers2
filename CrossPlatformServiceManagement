{
  "schemaVersion": "2.2",
  "description": "Cross-platform service management for patch remediation",
  "parameters": {
    "executionTimeout": {
      "type": "String",
      "default": "3600",
      "description": "Timeout for command execution"
    }
  },
  "mainSteps": [
    {
      "action": "aws:runPowerShellScript",
      "name": "WindowsServiceManagement",
      "precondition": {
        "StringEquals": ["platformType", "Windows"]
      },
      "inputs": {
        "timeoutSeconds": "{{ executionTimeout }}",
        "runCommand": [
          "Write-Output 'Starting Windows service management for patch remediation'",
          "# Create directory for service tracking",
          "New-Item -ItemType Directory -Path 'C:\\temp' -Force -ErrorAction SilentlyContinue",
          "# Define services that commonly interfere with patching",
          "$conflictingServices = @('IISADMIN', 'W3SVC', 'MSSQLSERVER', 'SQLSERVERAGENT', 'MSSQLServerADHelper100', 'SQLBrowser', 'Spooler')",
          "$stoppedServices = @()",
          "# Stop conflicting services and track them",
          "foreach ($serviceName in $conflictingServices) {",
          "    $service = Get-Service -Name $serviceName -ErrorAction SilentlyContinue",
          "    if ($service -and $service.Status -eq 'Running') {",
          "        try {",
          "            Stop-Service -Name $service.Name -Force -ErrorAction Stop",
          "            $stoppedServices += $service.Name",
          "            Write-Output \"Successfully stopped service: $($service.Name)\"",
          "        } catch {",
          "            Write-Output \"Failed to stop service: $($service.Name) - $($_.Exception.Message)\"",
          "        }",
          "    } else {",
          "        Write-Output \"Service $serviceName not found or not running\"",
          "    }",
          "}",
          "# Save list of stopped services for restart later",
          "if ($stoppedServices.Count -gt 0) {",
          "    $stoppedServices | Out-File -FilePath 'C:\\temp\\stopped_services.txt' -Encoding UTF8",
          "    Write-Output \"Saved list of $($stoppedServices.Count) stopped services to C:\\temp\\stopped_services.txt\"",
          "} else {",
          "    Write-Output 'No services needed to be stopped'",
          "}",
          "Write-Output 'Windows service management completed successfully'"
        ]
      }
    },
    {
      "action": "aws:runShellScript",
      "name": "LinuxServiceManagement",
      "precondition": {
        "StringEquals": ["platformType", "Linux"]
      },
      "inputs": {
        "timeoutSeconds": "{{ executionTimeout }}",
        "runCommand": [
          "#!/bin/bash",
          "echo 'Starting Linux service management for patch remediation'",
          "# Define services that commonly interfere with patching (RHEL/CentOS compatible)",
          "SERVICES_TO_MANAGE=('httpd' 'nginx' 'apache2' 'mysql' 'mysqld' 'mariadb' 'postgresql' 'tomcat' 'tomcat8' 'tomcat9' 'docker')",
          "STOPPED_SERVICES=()",
          "# Stop conflicting services and track them",
          "for service in \"${SERVICES_TO_MANAGE[@]}\"; do",
          "    if systemctl is-active --quiet \"$service\" 2>/dev/null; then",
          "        if systemctl stop \"$service\" 2>/dev/null; then",
          "            STOPPED_SERVICES+=(\"$service\")",
          "            echo \"Successfully stopped service: $service\"",
          "        else",
          "            echo \"Failed to stop service: $service\"",
          "        fi",
          "    else",
          "        echo \"Service $service not found or not running\"",
          "    fi",
          "done",
          "# Save list of stopped services for restart later",
          "if [ ${#STOPPED_SERVICES[@]} -gt 0 ]; then",
          "    printf '%s\\n' \"${STOPPED_SERVICES[@]}\" > /tmp/stopped_services.txt",
          "    echo \"Saved list of ${#STOPPED_SERVICES[@]} stopped services to /tmp/stopped_services.txt\"",
          "else",
          "    echo 'No services needed to be stopped'",
          "fi",
          "# Show current service states",
          "echo 'Current service states after management:'",
          "for service in \"${SERVICES_TO_MANAGE[@]}\"; do",
          "    if systemctl is-active --quiet \"$service\" 2>/dev/null; then",
          "        echo \"$service: RUNNING\"",
          "    elif systemctl list-unit-files --type=service | grep -q \"^$service.service\"; then",
          "        echo \"$service: STOPPED\"",
          "    fi",
          "done",
          "echo 'Linux service management completed successfully'"
        ]
      }
    }
  ]
}
