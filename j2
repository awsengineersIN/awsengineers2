Perfect! Here's exactly what you need - separate Groovy scripts for each parameter and a dedicated pipeline script that assumes roles, executes Lambda, and displays logs:

üéØ Individual Parameter Groovy Scripts
1. SCOPE Parameter (Simple Choice)
groovy
choice(
    name: 'SCOPE',
    choices: ['Account', 'OU'],
    description: 'Select whether to inventory a single AWS account or an entire Organizational Unit'
)
2. TARGET Parameter (Dynamic with Role Assumption)
groovy
[$class: 'CascadeChoiceParameter',
    choiceType: 'PT_SINGLE_SELECT',
    name: 'TARGET',
    referencedParameters: 'SCOPE',
    script: [$class: 'GroovyScript',
        sandbox: true,
        script: '''
            // Configuration - UPDATE THESE VALUES
            def ROLE_ARN = "arn:aws:iam::123456789012:role/JenkinsOrganizationsReadRole"
            def EXTERNAL_ID = "your-external-id-here"  // Remove if not needed
            
            // Python script that assumes role and fetches data
            def pythonScript = """
import boto3
import json
import sys

scope = '${SCOPE}'
role_arn = '${ROLE_ARN}'
external_id = '${EXTERNAL_ID}'

try:
    sts = boto3.client('sts', region_name='us-east-1')
    
    assume_role_kwargs = {
        'RoleArn': role_arn,
        'RoleSessionName': 'jenkins-parameter-discovery'
    }
    
    if external_id and external_id != 'your-external-id-here':
        assume_role_kwargs['ExternalId'] = external_id
    
    credentials = sts.assume_role(**assume_role_kwargs)['Credentials']
    
    org_client = boto3.client(
        'organizations',
        aws_access_key_id=credentials['AccessKeyId'],
        aws_secret_access_key=credentials['SecretAccessKey'],
        aws_session_token=credentials['SessionToken']
    )
    
    items = []
    
    if scope == 'Account':
        paginator = org_client.get_paginator('list_accounts')
        for page in paginator.paginate():
            for account in page.get('Accounts', []):
                if account.get('Status') == 'ACTIVE':
                    items.append(account['Name'])
    else:
        def get_ous(parent_id=None):
            ous = []
            if not parent_id:
                roots = org_client.list_roots()['Roots']
                for root in roots:
                    ous.extend(get_ous(root['Id']))
            else:
                try:
                    paginator = org_client.get_paginator('list_organizational_units_for_parent')
                    for page in paginator.paginate(ParentId=parent_id):
                        for ou in page.get('OrganizationalUnits', []):
                            ous.append(ou['Name'])
                            ous.extend(get_ous(ou['Id']))
                except:
                    pass
            return ous
        
        items = get_ous()
    
    print(json.dumps(sorted(list(set(items)))))
    
except Exception as e:
    print(json.dumps([f'Error: {str(e)}']))
""".stripIndent()
            
            try {
                def scriptFile = File.createTempFile("aws_org", ".py")
                scriptFile.text = pythonScript
                scriptFile.deleteOnExit()
                
                def process = new ProcessBuilder(['python3', scriptFile.absolutePath]).start()
                def output = process.inputStream.text.trim()
                process.waitFor()
                
                if (process.exitValue() == 0 && output) {
                    return new groovy.json.JsonSlurper().parseText(output) ?: ['No items found']
                } else {
                    return ['Error: Failed to fetch data']
                }
                
            } catch (Exception e) {
                return ["Error: ${e.message}"]
            }
        '''
    ]
]
3. RESOURCES Parameter (Multi-select)
groovy
extendedChoice(
    name: 'RESOURCES',
    type: 'PT_CHECKBOX',
    multiSelectDelimiter: ',',
    value: 'EC2,S3,Lambda,RDS,DynamoDB,Glue,Eventbridge,StepFunctions,SecurityHub,Config',
    visibleItemCount: 10,
    description: 'Select AWS services to include in the inventory report'
)
4. EMAIL Parameter (Text input)
groovy
text(
    name: 'EMAIL',
    defaultValue: 'ops-team@company.com',
    description: 'Enter recipient email addresses (comma-separated for multiple recipients)'
)
5. FALLBACK_REGIONS Parameter (Optional)
groovy
string(
    name: 'FALLBACK_REGIONS',
    defaultValue: 'us-east-1,us-west-2',
    description: 'Comma-separated regions to use if dynamic region discovery fails (optional)'
)
üöÄ Complete Pipeline Script
This pipeline assumes role, executes Lambda, prints output logs, and exits:

groovy
pipeline {
    agent any
    
    environment {
        // UPDATE THESE VALUES
        LAMBDA_ARN = 'arn:aws:lambda:us-east-1:123456789012:function:aws-inventory'
        LAMBDA_ROLE_ARN = 'arn:aws:iam::123456789012:role/JenkinsLambdaExecutionRole'
        EXTERNAL_ID = 'your-external-id-here'  // Remove if not needed
        AWS_DEFAULT_REGION = 'us-east-1'
    }
    
    stages {
        stage('Assume AWS Role') {
            steps {
                script {
                    echo "üîë Assuming AWS role for Lambda execution..."
                    
                    // Assume role command
                    def assumeRoleCmd = """
                        aws sts assume-role \\
                            --role-arn ${env.LAMBDA_ROLE_ARN} \\
                            --role-session-name jenkins-lambda-execution \\
                            --duration-seconds 3600
                    """
                    
                    // Add external ID if configured
                    if (env.EXTERNAL_ID && env.EXTERNAL_ID != 'your-external-id-here') {
                        assumeRoleCmd += " --external-id ${env.EXTERNAL_ID}"
                    }
                    
                    def result = sh(script: assumeRoleCmd, returnStdout: true).trim()
                    def roleResponse = new groovy.json.JsonSlurper().parseText(result)
                    
                    // Set temporary credentials
                    env.AWS_ACCESS_KEY_ID = roleResponse.Credentials.AccessKeyId
                    env.AWS_SECRET_ACCESS_KEY = roleResponse.Credentials.SecretAccessKey
                    env.AWS_SESSION_TOKEN = roleResponse.Credentials.SessionToken
                    
                    echo "‚úÖ Successfully assumed role"
                }
            }
        }
        
        stage('Execute Lambda') {
            steps {
                script {
                    echo "üöÄ Executing AWS Lambda function..."
                    
                    // Build payload
                    def resourceList = params.RESOURCES.tokenize(',').collect { it.trim() }
                    def payload = [
                        scope: params.SCOPE,
                        target: params.TARGET,
                        resources: resourceList,
                        email: params.EMAIL
                    ]
                    
                    if (params.FALLBACK_REGIONS && params.FALLBACK_REGIONS.trim() != '') {
                        payload.fallback_regions = params.FALLBACK_REGIONS.split(',').collect { it.trim() }
                    }
                    
                    def payloadJson = groovy.json.JsonOutput.toJson(payload)
                    
                    // Invoke Lambda
                    def lambdaCommand = """
                        aws lambda invoke \\
                            --function-name ${env.LAMBDA_ARN} \\
                            --payload '${payloadJson}' \\
                            --cli-binary-format raw-in-base64-out \\
                            --log-type Tail \\
                            lambda-response.json
                    """
                    
                    sh lambdaCommand
                    echo "‚úÖ Lambda function executed"
                }
            }
        }
        
        stage('Display Lambda Output') {
            steps {
                script {
                    echo "üìã Lambda Function Output:"
                    echo "=" * 80
                    
                    // Read and display response
                    def responseText = readFile('lambda-response.json').trim()
                    def response = new groovy.json.JsonSlurper().parseText(responseText)
                    
                    if (response.errorMessage) {
                        echo "‚ùå LAMBDA ERROR:"
                        echo "   ${response.errorMessage}"
                        if (response.stackTrace) {
                            echo "   Stack Trace:"
                            response.stackTrace.each { trace -> echo "     ${trace}" }
                        }
                        error("Lambda execution failed")
                    } else {
                        echo "‚úÖ LAMBDA SUCCESS:"
                        echo responseText
                    }
                    
                    echo "=" * 80
                }
            }
        }
        
        stage('Display Lambda Logs') {
            steps {
                script {
                    echo "üìú Lambda Execution Logs:"
                    echo "=" * 80
                    
                    try {
                        // Get function name from ARN
                        def functionName = env.LAMBDA_ARN.split(':')[6]
                        def logGroupName = "/aws/lambda/${functionName}"
                        
                        // Get latest log stream
                        def logStreamCmd = """
                            aws logs describe-log-streams \\
                                --log-group-name ${logGroupName} \\
                                --order-by LastEventTime \\
                                --descending \\
                                --max-items 1 \\
                                --query 'logStreams[0].logStreamName' \\
                                --output text
                        """
                        
                        def latestStream = sh(script: logStreamCmd, returnStdout: true).trim()
                        
                        if (latestStream && latestStream != 'None') {
                            // Get log events from last 10 minutes
                            def logEventsCmd = """
                                aws logs get-log-events \\
                                    --log-group-name ${logGroupName} \\
                                    --log-stream-name ${latestStream} \\
                                    --start-time \$(date -d '10 minutes ago' +%s)000 \\
                                    --query 'events[*].message' \\
                                    --output text
                            """
                            
                            def logs = sh(script: logEventsCmd, returnStdout: true).trim()
                            
                            if (logs && logs != '') {
                                echo logs
                            } else {
                                echo "No recent logs found"
                            }
                        } else {
                            echo "No log streams found"
                        }
                        
                    } catch (Exception e) {
                        echo "Could not retrieve logs: ${e.message}"
                    }
                    
                    echo "=" * 80
                }
            }
        }
    }
    
    post {
        always {
            script {
                // Cleanup
                sh 'rm -f lambda-response.json || true'
                env.AWS_ACCESS_KEY_ID = ''
                env.AWS_SECRET_ACCESS_KEY = ''
                env.AWS_SESSION_TOKEN = ''
                
                echo "üèÅ Pipeline completed"
            }
        }
        
        success {
            echo "üéâ AWS Inventory pipeline completed successfully!"
        }
        
        failure {
            echo "üí• AWS Inventory pipeline failed - check logs above"
        }
    }
}
üìã Setup Instructions
Add Parameters: Copy each parameter script into your Jenkins job's parameter section individually

Update Configuration: Replace the ARNs and External ID in both parameter and pipeline scripts

Install Plugins: Active Choices Plugin and Extended Choice Parameter Plugin

Create Pipeline: Copy the pipeline script into your Jenkins pipeline configuration

The pipeline will:

‚úÖ Assume your specified AWS role

üöÄ Execute the Lambda function with the provided parameters

üìã Display the complete Lambda response

üìú Show Lambda execution logs

üßπ Clean up and exit
